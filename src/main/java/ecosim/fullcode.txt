Main.java:
<code>
package ecosim;


import ecosim.controller.EcosystemController;

public class Main {

    public static void main(String[] args) {
        EcosystemController ecosystemController = new EcosystemController();
        ecosystemController.run();
    }

}

</code>

attrs\Movable.java:
<code>
package ecosim.attrs;


import ecosim.map.Coords;

/**
 * An object with *adjustable* 2D coordinates.
 * 
 * @author darragh0
 */
public abstract class Movable {

    protected final Coords coords;

    public Movable() {
        // initialise coordinates at (0,0) before placment
        this.coords = new Coords(0, 0);
    }

    public void setCoords(final int x, final int y) {
        this.coords.setX(x);
        this.coords.setY(y);
    }

    public final int getX() {
        return this.coords.getX();
    }

    public final int getY() {
        return this.coords.getY();
    }

}

</code>

attrs\Observable.java:
<code>
package ecosim.attrs;


import ecosim.enm.Event;
import ecosim.man.ChangeMan;


public abstract class Observable {
    protected ChangeMan changeManager;

    public Observable(ChangeMan changeManager) {
        this.changeManager = changeManager;
    }

    public void attach(Observer observer) {
        changeManager.register(this, observer);
    }

    public void detach(Observer observer) {
        changeManager.unregister(this, observer);
    }

    public void notifyObservers() {
        changeManager.notifyObservers(this);
    }

    public abstract Event getCurrentState();

}

</code>

attrs\Observer.java:
<code>
package ecosim.attrs;

public interface Observer {
    void update(Observable observable);
}

</code>

common\Util.java:
<code>
package ecosim.common;


import java.util.OptionalInt;
import java.util.concurrent.ThreadLocalRandom;


public final class Util {

    private Util() {
        throw new UnsupportedOperationException("This class cannot be instantiated.");
    }

    /**
     * Return random int in given range (inclusive).
     * 
     * @param min Min. range value
     * @param max Max. range value
     */
    public static int randInt(final int min, final int max) {
        return ThreadLocalRandom.current().nextInt(min, max + 1);
    }

    /**
     * Convert a string to title case (e.g. "hello there" -> "Hello There").
     *  
     * @param str String to convert
     * @return The input string with the first letter of each word capitalized
     */
    public static String title(final String str) {
        if (str == null || str.isBlank() || str.isEmpty()) {
            return str;
        }

        StringBuilder sb = new StringBuilder();
        boolean capNext = true;

        for (char c : str.toCharArray()) {
            if (Character.isWhitespace(c)) {
                capNext = true;
                sb.append(c);
            } else if (capNext) {
                sb.append(Character.toUpperCase(c));
                capNext = false;
            } else {
                sb.append(Character.toLowerCase(c));
            }
        }

        return sb.toString();
    }

    /**
     * Substring a string from start to end index (Can use negative indices).
     * 
     * @param str The string to substring
     * @param start The start index (inclusive)
     * @param end The end index (exclusive)
     */
    public static String sub(final String str, final int start, final int end) {
        final int len = str.length();
        final int s = start < 0 ? len + start : start;
        final int e = end < 0 ? len + end : end;

        if (s < 0 || e > len || s > e) {
            throw new IndexOutOfBoundsException("Invalid start/end indices");
        }

        return str.substring(s, e);
    }

    /**
     * Parse a string to an integer.
     *
     * @param str
     * @return OptionalInt containing the parsed integer, or empty if NaN
     */
    public static OptionalInt parseInt(final String str) {
        try {
            return OptionalInt.of(Integer.parseInt(str));
        } catch (NumberFormatException e) {
            return OptionalInt.empty();
        }
    }

}

</code>

common\io\ConsoleIO.java:
<code>
package ecosim.common.io;


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.function.BiConsumer;
import java.util.function.Consumer;


public final class ConsoleIO {

    private static final String ANSI_REGEX = "\u001B\\[[;\\d]*m";
    public static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    private static final int COLS;
    private static final int LINES;

    static {
        COLS = Integer.parseInt(System.getenv().getOrDefault("COLUMNS", "0"));
        LINES = Integer.parseInt(System.getenv().getOrDefault("LINES", "0"));
    }

    private ConsoleIO() {
        throw new UnsupportedOperationException("This class cannot be instantiated.");
    }

    public static void clearTerminal() {
        System.out.print("\033[H\033[2J");
    }

    public static void toggleCursor(boolean show) {
        System.out.print(show ? "\033[?25h" : "\033[?25l");
    }

    public static void cursorUp(int lines) {
        System.out.printf("\033[%dA", lines);
    }

    public static int getTermCols() {
        return COLS;
    }

    public static int getTermLines() {
        return LINES;
    }

    public static String strInput(final String prompt) {
        return strInput(prompt, false);
    }

    public static String strInput(final boolean allowEmpty) {
        return strInput("", allowEmpty);
    }

    public static boolean notInRange(int num, int min, int max) {
        if (min > max)
            throw new IllegalArgumentException("Min cannot be greater than max");
        return num < min || num > max;
    }

    public static String prettify(String str, final Object... formatArgs) {
        return TextPrettifier.prettify(str, formatArgs);
    }

    public static BiConsumer<StringBuilder, String> add = 
        (builder, str) -> builder.append(prettify(str)).append("\n");

    public static void pprint(String format, final Object... args) {
        System.out.print(prettify(format, args));
    }

    public static void pprintln(String format, final Object... args) {
        System.out.println(prettify(format, args));
    }

    public static void pprintCenter(String str, final Object... args) {
        str = prettify(str, args);
        final String lines[] = str.split("\n");
        Consumer<String> print = lines.length > 1 ? System.out::println : System.out::print;

        for (String line : lines) {
            final String noAnsi = line.replaceAll(ANSI_REGEX, "");
            final int pad = (COLS - noAnsi.length()) / 2;
            final String out = pad < 0 ? line : " ".repeat(pad) + line;
            print.accept(out);
        }
    }

    public static void eprint(String str, final Object... formatArgs) {
        System.err.println(prettify("[flr:%s]".formatted(str), formatArgs));
    }

    private static String strInput(final String prompt, final boolean allowEmpty) {
        while (true) {
            pprint(prompt);
            String in;

            try {
                in = reader.readLine();
            } catch (IOException e) {
                return "";
            }

            if (in.isEmpty() && !allowEmpty)
                eprint("Input cannot be empty");
            else
                return in;
        }
    }

}

</code>

common\io\FileIO.java:
<code>
package ecosim.common.io;


import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Optional;
import java.util.logging.Level;

import org.json.JSONException;
import org.json.JSONObject;

import ecosim.man.LoggerMan;
import ecosim.misc.EcosystemConfig;


public final class FileIO {

    private FileIO() {
        throw new UnsupportedOperationException("This class cannot be instantiated.");
    }

    public static Optional<JSONObject> readJSONFile(String path) {
        path = "src/main/resources/json/" + path;
        JSONObject json = null;

        try {
            final String content = new String(Files.readAllBytes(Paths.get(path)));
            json = new JSONObject(content);
        } catch (IOException e) {
            LoggerMan.log(Level.SEVERE, "Error reading JSON file: {0}", e.getMessage());
        } catch (JSONException e) {
            LoggerMan.log(Level.SEVERE, "Invalid JSON format: {0}", e.getMessage());
        }

        return Optional.ofNullable(json);
    }

    public static boolean mkdir(final String path) {
        try {
            Files.createDirectories(Paths.get(path));
            return true;
        } catch (IOException e) {
            LoggerMan.log(Level.SEVERE, "Error creating directory: {0}", e.getMessage());
            return false;
        }
    }

    public static Optional<EcosystemConfig> parseEcosystemConfig() {
        final String[] keys = { "initialPlants", "initialAnimals" };

        final Optional<JSONObject> jsonFile = FileIO.readJSONFile("ecosystem_config.json");
        if (jsonFile.isEmpty()) {
            LoggerMan.log(Level.SEVERE, "Could not parse ecosystem config");
            return null;
        }

        final JSONObject json = jsonFile.get();
        for (String key : keys) {
            boolean missing = false;
            if (!json.has(key)) {
                missing = true;
                LoggerMan.log(Level.SEVERE, "Missing key in JSON: {0}", key);
            }
            if (missing)
                return Optional.empty();
        }

        final int animals;
        final int plants;
        try {
            plants = json.getInt(keys[0]);
            animals = json.getInt(keys[1]);
        } catch (JSONException e) {
            LoggerMan.log(Level.SEVERE, "Invalid JSON format: {0}", e.getMessage());
            return Optional.empty();
        }

        final EcosystemConfig cfg = new EcosystemConfig(animals, plants);
        return Optional.ofNullable(cfg);
    }

}

</code>

common\io\TextPrettifier.java:
<code>
package ecosim.common.io;


import java.util.Stack;
import java.util.HashMap;
import java.util.Map;
import ecosim.common.io.enm.DarkBG;
import ecosim.common.io.enm.DarkFG;
import ecosim.common.io.enm.LightBG;
import ecosim.common.io.enm.LightFG;
import ecosim.common.io.enm.Reset;
import ecosim.common.io.enm.TextStyle;


final class TextPrettifier {

    private static final Map<String, String> COLOR_MAP = new HashMap<>();

    static {
        COLOR_MAP.put("flr", LightFG.RED.getCode());
        COLOR_MAP.put("flg", LightFG.GREEN.getCode());
        COLOR_MAP.put("fly", LightFG.YELLOW.getCode());
        COLOR_MAP.put("flb", LightFG.BLUE.getCode());
        COLOR_MAP.put("flm", LightFG.MAGENTA.getCode());
        COLOR_MAP.put("flc", LightFG.CYAN.getCode());
        COLOR_MAP.put("flw", LightFG.WHITE.getCode());

        COLOR_MAP.put("fdr", DarkFG.RED.getCode());
        COLOR_MAP.put("fdg", DarkFG.GREEN.getCode());
        COLOR_MAP.put("fdy", DarkFG.YELLOW.getCode());
        COLOR_MAP.put("fdb", DarkFG.BLUE.getCode());
        COLOR_MAP.put("fdm", DarkFG.MAGENTA.getCode());
        COLOR_MAP.put("fdc", DarkFG.CYAN.getCode());
        COLOR_MAP.put("fdw", DarkFG.WHITE.getCode());

        COLOR_MAP.put("blr", LightBG.RED.getCode());
        COLOR_MAP.put("blg", LightBG.GREEN.getCode());
        COLOR_MAP.put("bly", LightBG.YELLOW.getCode());
        COLOR_MAP.put("blb", LightBG.BLUE.getCode());
        COLOR_MAP.put("blm", LightBG.MAGENTA.getCode());
        COLOR_MAP.put("blc", LightBG.CYAN.getCode());
        COLOR_MAP.put("blw", LightBG.WHITE.getCode());

        COLOR_MAP.put("bdr", DarkBG.RED.getCode());
        COLOR_MAP.put("bdg", DarkBG.GREEN.getCode());
        COLOR_MAP.put("bdy", DarkBG.YELLOW.getCode());
        COLOR_MAP.put("bdb", DarkBG.BLUE.getCode());
        COLOR_MAP.put("bdm", DarkBG.MAGENTA.getCode());
        COLOR_MAP.put("bdc", DarkBG.CYAN.getCode());
        COLOR_MAP.put("bdw", DarkBG.WHITE.getCode());
    }

    private static String applyStyle(String txt) {
        txt = txt.replaceAll("\\*\\*(.*?)\\*\\*", TextStyle.BOLD.getCode() + "$1" + Reset.BOLD.getCode());
        txt = txt.replaceAll("\\*(.*?)\\*", TextStyle.ITALIC.getCode() + "$1" + Reset.ITALIC.getCode());
        txt = txt.replaceAll("#(.*?)#", TextStyle.UNDERLINE.getCode() + "$1" + Reset.UNDERLINE.getCode());
        txt = txt.replaceAll("-=-(.*?)-=-", TextStyle.STRIKETHROUGH.getCode() + "$1" + Reset.STRIKETHROUGH.getCode());
        txt = txt.replaceAll("\\^^(.*?)\\^^", TextStyle.REVERSE.getCode() + "$1" + Reset.REVERSE.getCode());
        return txt;
    }

    private static String applyColor(final String txt) {
        final StringBuilder result = new StringBuilder();
        final Stack<String> tagStack = new Stack<>();

        int i = 0;
        while (i < txt.length()) {
            char c = txt.charAt(i);

            // Look for opening color tag [xxx:
            if (c == '[' && i + 5 < txt.length() && txt.charAt(i + 4) == ':') {
                final String potentialTag = txt.substring(i + 1, i + 4).toLowerCase();

                if (COLOR_MAP.containsKey(potentialTag)) {
                    // Valid color tag found
                    tagStack.push(potentialTag);
                    result.append(COLOR_MAP.get(potentialTag));
                    i += 5; // Skip past the [tag:
                } else {
                    // Not a valid tag, treat as regular char
                    result.append(c);
                    i++;
                }
            }
            // Look for closing bracket
            else if (c == ']' && !tagStack.isEmpty()) {
                final String tag = tagStack.pop();

                // Reset appropriate color component
                if (tag.startsWith("f")) {
                    result.append(Reset.FG.getCode());
                } else if (tag.startsWith("b")) {
                    result.append(Reset.BG.getCode());
                }

                // Reapply any remaining colors in the stack
                for (String remainingTag : tagStack) {
                    result.append(COLOR_MAP.get(remainingTag));
                }

                i++; // Move past the closing bracket
            }
            // Regular character
            else {
                result.append(c);
                i++;
            }
        }

        return result.toString();
    }

    public static String prettify(String fstr, final Object... fargs) {
        fstr = String.format(fstr, fargs);
        return applyColor(applyStyle(fstr));
    }

}

</code>

common\io\enm\BoxDrawingChar.java:
<code>
package ecosim.common.io.enm;


public enum BoxDrawingChar {
    HORIZONTAL("‚îÄ"),
    TOP_LEFT("‚îå"),
    TOP_RIGHT("‚îê"),
    VERTICAL("‚îÇ"),
    BOTTOM_LEFT("‚îî"),
    BOTTOM_RIGHT("‚îò");

    private final String value;

    BoxDrawingChar(String value) {
        this.value = value;
    }

    public String getValue() {
        return this.value;
    }

    public String repeat(int n) {
        return this.value.repeat(n);
    }

}

</code>

common\io\enm\Color.java:
<code>
package ecosim.common.io.enm;


public enum Color {
    RED("\033[91m"),
    GREEN("\033[92m"),
    YELLOW("\033[93m"),
    BLUE("\033[94m"),
    MAGENTA("\033[95m"),
    CYAN("\033[96m"),
    NONE("\033[0;0m");

    private final String value;

    Color(String value) {
        this.value = value;
    }

    public String getValue() {
        return this.value;
    }

    public static Color from(char ch) {
        for (Color style : Color.values()) {
            if (style.toString().charAt(0) == Character.toUpperCase(ch)) {
                return style;
            }
        }
        return Color.NONE;
    }

}

</code>

common\io\enm\DarkBG.java:
<code>
package ecosim.common.io.enm;


public enum DarkBG {
    RED("\033[41m"),
    GREEN("\033[42m"),
    YELLOW("\033[43m"),
    BLUE("\033[44m"),
    MAGENTA("\033[45m"),
    CYAN("\033[46m"),
    WHITE("\033[47m");

    private final String code;

    private DarkBG(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }

}


</code>

common\io\enm\DarkFG.java:
<code>
package ecosim.common.io.enm;


public enum DarkFG {
    RED("\033[31m"),
    GREEN("\033[32m"),
    YELLOW("\033[33m"),
    BLUE("\033[34m"),
    MAGENTA("\033[35m"),
    CYAN("\033[36m"),
    WHITE("\033[37m");

    private final String code;

    private DarkFG(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }

}


</code>

common\io\enm\LightBG.java:
<code>
package ecosim.common.io.enm;


public enum LightBG {
    RED("\033[101m"),
    GREEN("\033[102m"),
    YELLOW("\033[103m"),
    BLUE("\033[104m"),
    MAGENTA("\033[105m"),
    CYAN("\033[106m"),
    WHITE("\033[107m");

    private final String code;

    private LightBG(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }

}

</code>

common\io\enm\LightFG.java:
<code>
package ecosim.common.io.enm;


public enum LightFG {
    RED("\033[91m"),
    GREEN("\033[92m"),
    YELLOW("\033[93m"),
    BLUE("\033[94m"),
    MAGENTA("\033[95m"),
    CYAN("\033[96m"),
    WHITE("\033[97m");

    private final String code;

    private LightFG(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }

}


</code>

common\io\enm\Reset.java:
<code>
package ecosim.common.io.enm;


public enum Reset {
    FG("\033[39m"),
    BG("\033[49m"),
    BOLD("\033[22m"),
    ITALIC("\033[23m"),
    UNDERLINE("\033[24m"),
    REVERSE("\033[27m"),
    STRIKETHROUGH("\033[29m"),
    ALL("\033[0m");

    private final String code;

    private Reset(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }

}

</code>

common\io\enm\TextStyle.java:
<code>
package ecosim.common.io.enm;


public enum TextStyle {
    BOLD("\033[1m"),
    ITALIC("\033[3m"),
    UNDERLINE("\033[4m"),
    REVERSE("\033[7m"),
    STRIKETHROUGH("\033[9m"),
    RESET("\033[0m");

    private final String code;

    private TextStyle(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }

}


</code>

controller\EcosystemController.java:
<code>
package ecosim.controller;

import java.util.List;

import ecosim.enm.Biome;
import ecosim.man.EcosystemMan;
import ecosim.misc.AnimalDescriptor;
import ecosim.misc.PlantDescriptor;
import ecosim.view.ActionsView;
import ecosim.view.EnvironmentView;
import ecosim.view.InputPromptView;
import ecosim.view.MapView;
import ecosim.view.ReportView;
import ecosim.view.SplashScreenView;

public class EcosystemController {

    private final EcosystemMan man;
    
    // Individual view components
    private final InputPromptView inputView;
    private final MapView mapView;
    private final ReportView reportView;
    private final ActionsView actionsView;
    private final EnvironmentView environmentView;

    public EcosystemController() {
        this.man = new EcosystemMan();
        
        // Initialize individual view components
        this.inputView = new InputPromptView();
        this.mapView = new MapView();
        this.reportView = new ReportView();
        this.actionsView = new ActionsView();
        this.environmentView = new EnvironmentView();
    }

    public void run() {
        Runtime.getRuntime().addShutdownHook(new Thread(this::exit));
        this.showWelcomeScreen();
        this.setup();
        this.runSimulation();
    }

    private void showWelcomeScreen() {
        SplashScreenView.show();
        System.out.println("Welcome to the *Ecosystem Simulator* üå≥");
        System.out.println("To setup the ecosystem, please follow the prompts below.\n");
    }

    private void exit() {
        // Using console output directly for exit message
        System.out.println("\n[flr:(Simulator finished w/ exit code 0)]");
    }

    public void setup() {
        final Biome biome = this.inputView.promptBiomeSelection();
        this.man.setBiome(biome);

        final List<AnimalDescriptor> animals =
            this.inputView.promptAnimalSelection(this.man.getBiomeAnimals(), this.man.getInitialAnimals());
        final List<PlantDescriptor> plants =
            this.inputView.promptPlantSelection(this.man.getBiomePlants(), this.man.getInitialPlants());

        this.man.loadEcosystem(animals, plants, biome.name());
        this.man.populateMap();
        this.mapView.displayEcosytemMap(this.man);
    }

    public void runSimulation() {
        this.man.updateEnvironmentConditions();
        this.environmentView.displayEnvironmentConditions(this.man);
        this.environmentView.displayTimeStatus(man);
        
        // Set up action listener to display animal actions
        this.man.setActionListener(result -> this.actionsView.displayAnimalActions(result));
        
        this.actionsView.displayAnimalActionsHeader();
        for (int hour = 0; hour < 10; hour++) {
            if (hour == 5) {
                this.man.updateTimeOfDay();
                this.environmentView.displayTimeStatus(man);
            }
            this.man.processAnimalsTurn();
            this.man.checkOrganismsHealth();
        }
        
        this.mapView.displayEcosytemMap(this.man);
        this.reportView.displayDailyReport(this.man);
        this.man.resetNewAndDeadOrganisms();
    }
}
</code>

enm\ActivityState.java:
<code>
package ecosim.enm;

import static ecosim.common.Util.title;

/**
 * Enum representing the various activity states
 * an organism can be in, such as sleeping or hibernating.
 * 
 * @author jjola00
 */
public enum ActivityState {
    SLEEPING,
    HIBERNATING,
    AWAKE;

    @Override
    public String toString() {
        return title(this.name());
    }
}

</code>

enm\ActivityType.java:
<code>
package ecosim.enm;


public enum ActivityType {
    DIURNAL,
    NOCTURNAL;
}

</code>

enm\Biome.java:
<code>
package ecosim.enm;


import static ecosim.common.Util.title;


public enum Biome {
    DESERT,
    GRASSLAND;

    @Override
    public String toString() {
        return title(this.name());
    }

}

</code>

enm\Diet.java:
<code>
package ecosim.enm;


public enum Diet {
    HERBIVORE,
    CARNIVORE,
    OMNIVORE;
}

</code>

enm\Direction.java:
<code>
package ecosim.enm;


public enum Direction {
    NORTH(0, 1),
    EAST(1, 0),
    SOUTH(0, -1),
    WEST(-1, 0);

    private final int dx;
    private final int dy;

    Direction(final int dx, final int dy) {
        this.dx = dx;
        this.dy = dy;
    }

    public int getDx() {
        return this.dx;
    }

    public int getDy() {
        return this.dy;
    }

}

</code>

enm\Event.java:
<code>
package ecosim.enm;

public interface Event {
    String getIcon();
}
</code>

enm\Season.java:
<code>
package ecosim.enm;

import static ecosim.common.Util.title;

public enum Season implements Event {
    SPRING("üå∏"),
    SUMMER("üèñÔ∏è"),
    AUTUMN("üçÇ"),
    WINTER("‚òÉÔ∏è");

    private final String icon;

    @Override
    public String getIcon() {
        return this.icon;
    }

    @Override
    public String toString() {
        return title(this.name());
    }

    Season(String icon) {   
        this.icon = icon;
    }
    
}


</code>

enm\Size.java:
<code>
package ecosim.enm;


public enum Size {
    SMALL(10, 3),
    MEDIUM(20, 9),
    LARGE(30, 15);

    private final int maxHealth;
    private final int nutritionalValue;

    Size(int maxHealth, int nutritionalValue) {
        this.maxHealth = maxHealth;
        this.nutritionalValue = nutritionalValue;
    }

    public int getMaxHealth() {
        return this.maxHealth;
    }

    public int getNutritionalValue() {
        return this.nutritionalValue;
    }

}

</code>

enm\TimeOfDay.java:
<code>
package ecosim.enm;

import static ecosim.common.Util.title;

public enum TimeOfDay implements Event {
    DAY("üåÖ"),
    NIGHT("üåô");

    private final String icon;

    @Override
    public String getIcon() {
        return this.icon;
    }

    @Override
    public String toString() {
        return title(this.name());
    }

    TimeOfDay(String icon) {
        this.icon = icon;
    }
}


</code>

enm\Weather.java:
<code>
package ecosim.enm;

import static ecosim.common.Util.title;

public enum Weather implements Event {
    RAINY("üåßÔ∏è"),
    SUNNY("‚òÄÔ∏è"),
    DRY("üí®"),
    CLOUDY("‚òÅÔ∏è"),
    SNOWY("‚ùÑÔ∏è");

    private final String icon;

    @Override
    public String getIcon() {
        return this.icon;
    }


    @Override
    public String toString() {
       return title(this.name());
    }

    Weather(String icon) {
        this.icon = icon ;
    }
}

</code>

man\BiomeMan.java:
<code>
package ecosim.man;


import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.logging.Level;

import org.json.JSONException;
import org.json.JSONObject;

import ecosim.common.io.FileIO;
import ecosim.enm.ActivityType;
import ecosim.enm.Biome;
import ecosim.enm.Diet;
import ecosim.enm.Size;
import ecosim.misc.AnimalDescriptor;
import ecosim.misc.PlantDescriptor;


public class BiomeMan {

    private static final String JSON_FILE = "biome_natives.json";

    private final Biome biome;
    private final List<AnimalDescriptor> animals;
    private final List<PlantDescriptor> plants;

    public BiomeMan(final Biome biome) {
        this.biome = biome;
        this.animals = new ArrayList<>();
        this.plants = new ArrayList<>();
        LoggerMan.log(Level.INFO, "Biome created: " + this.biome.name());
    }

    public void setupBiome() {
        final String biomeName = this.biome.name();
        LoggerMan.log(Level.INFO, "Setting up biome: {0}", biomeName);
        final Optional<JSONObject> jsonFile = FileIO.readJSONFile(JSON_FILE);

        if (jsonFile.isEmpty()) {
            LoggerMan.log(Level.SEVERE, "Could not setup biome: {0}", biomeName);
            return;
        }

        final JSONObject json = jsonFile.get();
        if (!json.has(biomeName)) {
            LoggerMan.log(Level.SEVERE, "Biome not found: {0}", biomeName);
            return;
        }

        final JSONObject biomeData = json.getJSONObject(biomeName);

        // TODO: Make this a single method maybe (DRY principle and all that)
        this.initAnimalList(biomeData);
        this.initPlantList(biomeData);

        LoggerMan.log(Level.INFO, "Biome setup complete: {0}", biomeName);
    }

    private void initAnimalList(JSONObject biomeData) {
        final String key = "ANIMALS";
        
        if (!biomeData.has(key)) {
            LoggerMan.log(Level.SEVERE, "No animals found for biome: {0}", biome.name());
            return;
        }
        final JSONObject animalJson = biomeData.getJSONObject(key);

        for (final String animalKey : animalJson.keySet()) {
            final JSONObject animalData = animalJson.getJSONObject(animalKey);
            
            try {
                // Get the display name (either from JSON or use the key)
                final String displayName = animalData.optString("name", animalKey);
                
                // Create size enum
                final Size size;
                try {
                    size = Size.valueOf(animalData.getString("size"));
                } catch (IllegalArgumentException e) {
                    LoggerMan.log(Level.SEVERE, "Invalid size for animal: {0}", displayName);
                    continue;
                }
                
                // Create diet enum
                final Diet diet;
                try {
                    diet = Diet.valueOf(animalData.getString("diet"));
                } catch (IllegalArgumentException e) {
                    LoggerMan.log(Level.SEVERE, "Invalid diet for animal: {0}", displayName);
                    continue;
                }
                final ActivityType activityType;
                try {
                    activityType = ActivityType.valueOf(animalData.getString("activityType"));
                } catch (IllegalArgumentException e) {
                    LoggerMan.log(Level.SEVERE, "Invalid activity type for animal: {0}", displayName);
                    continue;
                }

                // Create animal descriptor without biome field
                final AnimalDescriptor animalDescriptor = new AnimalDescriptor(
                    displayName,
                    size,
                    diet,
                    activityType,
                    animalData.getBoolean("canHibernate"),
                    animalData.getString("sound"),
                    animalData.getString("symbol"));

                this.animals.add(animalDescriptor);
                LoggerMan.log(Level.INFO, "Loaded animal: {0}", displayName);
            } catch (JSONException ex) {
                LoggerMan.log(Level.SEVERE, "Error loading animal: {0}", ex.getMessage());
            }
        }

        LoggerMan.log(Level.INFO, "Loaded native {0} for biome: {1}", key, biome.name());
    }

    private void initPlantList(JSONObject biomeData) {
        final String key = "PLANTS";
        
        if (!biomeData.has(key)) {
            LoggerMan.log(Level.SEVERE, "No plants found for biome: {0}", biome.name());
            return;
        }

        final JSONObject plantJson = biomeData.getJSONObject(key);

        for (final String plantKey : plantJson.keySet()) {
            final JSONObject plantData = plantJson.getJSONObject(plantKey);
            
            try {
                // Get display name (either from JSON or use the key)
                final String displayName = plantData.optString("name", plantKey);
                
                // Create size enum
                final Size size;
                try {
                    size = Size.valueOf(plantData.optString("size", "MEDIUM"));
                } catch (IllegalArgumentException e) {
                    LoggerMan.log(Level.SEVERE, "Invalid size for plant: {0}", displayName);
                    continue;
                }

                final PlantDescriptor plantDescriptor = new PlantDescriptor(
                    displayName,
                    size,
                    plantData.getString("symbol"));

                this.plants.add(plantDescriptor);
                LoggerMan.log(Level.INFO, "Loaded plant: {0}", displayName);
            } catch (JSONException ex) {
                LoggerMan.log(Level.SEVERE, "Error loading plant: {0}", ex.getMessage());
            }
        }

        LoggerMan.log(Level.INFO, "Loaded native {0} for biome: {1}", key, biome.name());
    }

    public Biome getBiome() {
        return this.biome;
    }

    public List<AnimalDescriptor> getAnimals() {
        return this.animals;
    }

    public List<PlantDescriptor> getPlants() {
        return this.plants;
    }

}

</code>

man\ChangeMan.java:
<code>
package ecosim.man;


import ecosim.attrs.Observable;
import ecosim.attrs.Observer;


public interface ChangeMan {
    void register(Observable observable, Observer observer);

    void unregister(Observable observable, Observer observer);

    void notifyObservers(Observable subject);

}

</code>

man\EcosystemMan.java:
<code>
package ecosim.man;


import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.logging.Level;

import ecosim.common.io.FileIO;
import ecosim.enm.Biome;
import ecosim.enm.Season;
import ecosim.enm.TimeOfDay;
import ecosim.enm.Weather;
import ecosim.map.ActionResult;
import ecosim.map.ActionResult.ActionType;
import static ecosim.map.ActionResult.ActionType.SUCCESSFUL_EATING;
import ecosim.map.Grid;
import ecosim.map.Map;
import ecosim.map.Map.MapSize;
import ecosim.misc.AnimalDescriptor;
import ecosim.misc.EcosystemConfig;
import ecosim.misc.PlantDescriptor;
import ecosim.organism.animal.abs.Animal;
import ecosim.organism.builder.AnimalBuilder;
import ecosim.organism.builder.PlantBuilder;
import ecosim.organism.factory.BiomeOrganismFactory;
import ecosim.organism.factory.BiomeOrganismFactoryProvider;
import ecosim.organism.plant.abs.Plant;
import ecosim.view.ActionResultListener;


public class EcosystemMan {

    private final EnvironmentMan environment;
    private int dayCount;
    private final ArrayList<Animal> animals;
    private final ArrayList<Plant> plants;
    private final List<Animal> deadAnimals;
    private final List<Plant> deadPlants;
    private final List<Animal> newbornAnimals;
    private final Map map;
    private final EcosystemConfig config;

    private ActionResultListener actionListener;

    public EcosystemMan() {
        this.environment = new EnvironmentMan();
        this.dayCount = 0;
        this.animals = new ArrayList<>();
        this.plants = new ArrayList<>();
        this.deadAnimals = new ArrayList<>();
        this.deadPlants = new ArrayList<>();
        this.newbornAnimals = new ArrayList<>();
        this.map = Map.init(6, 6);
        this.config = this.loadConfig();
    }

    public void processAnimalsTurn() {
        // Create a copy of the animals list to safely iterate through
        List<Animal> currentAnimals = new ArrayList<>(this.animals);

        for (Animal a : currentAnimals) {
            // Skip animals that have already been removed
            if (!this.animals.contains(a)) {
                continue;
            }

            ActionResult result = a.move();
            ActionType actionType = result.getActionType();

            // Handle new offspring from breeding
            if (actionType == ActionType.SUCCESSFUL_BREEDING && result.getOffspring() != null) {
                Animal offspring = result.getOffspring();
                this.animals.add(offspring);
                this.newbornAnimals.add(offspring);

                // Register the new animal with environment observers
                this.environment.registerTimeOfDayObservers(offspring);
                this.environment.registerSeasonObservers(offspring);
            }

            if (actionType == SUCCESSFUL_EATING) {
                switch (result.getTarget()) {
                    case Plant plant -> {
                        if (plant.isDead()) {
                            this.plants.remove(plant);
                            this.deadPlants.add(plant);
                        }
                    }
                    case Animal animal -> {
                        this.animals.remove(animal);
                        this.deadAnimals.add(animal);
                    }
                    default -> LoggerMan.log(Level.WARNING, "Unknown target type: " + result.getTarget());
                }
            }

            if (actionListener != null) {
                actionListener.onActionPerformed(result);
            }
        }
    }

    public void resetNewAndDeadOrganisms() {
        this.deadAnimals.clear();
        this.deadPlants.clear();
        this.newbornAnimals.clear();
    }

    public void checkOrganismsHealth() {

        List<Animal> animalsToRemove = new ArrayList<>();

        for (Animal animal : this.animals) {
            if (animal.getHealth() <= 0) {
                animalsToRemove.add(animal);
            }
        }
        for (Animal animal : animalsToRemove) {
            this.map.getGrid().rmv(animal);
            this.animals.remove(animal);
            this.deadAnimals.add(animal);

            if (actionListener != null) {
                ActionResult deathResult = new ActionResult(
                    ActionType.DIED,
                    animal, null,
                    animal.getX(), animal.getY());
                actionListener.onActionPerformed(deathResult);
            }
        }

    }

    private void createAnimal(AnimalDescriptor descriptor, String biomeName) {
    try{
        Biome biome = Biome.valueOf(biomeName);

        BiomeOrganismFactory factory = BiomeOrganismFactoryProvider.getFactory(biome);
    
    // Use the factory to get a builder
        AnimalBuilder builder = factory.createAnimalBuilder(descriptor);
        
        // Build the animal with basic properties and apply decorators
        Animal animal = builder
            .buildBasicProperties()
            .applyDecorators()
            .build();
        
        // Register observers and add to the ecosystem
        this.environment.registerTimeOfDayObservers(animal);
            this.environment.registerSeasonObservers(animal);
            this.animals.add(animal);
        } catch (IllegalArgumentException e) {
            LoggerMan.log(Level.SEVERE, "Invalid biome name: " + biomeName);
        }
    }
    


    public void createPlant(PlantDescriptor descriptor, String biomeName) {
        try{
            Biome biome = Biome.valueOf(biomeName);

            BiomeOrganismFactory factory = BiomeOrganismFactoryProvider.getFactory(biome);
            
            // Use the factory to get a builder
            PlantBuilder builder = factory.createPlantBuilder(descriptor);
            
            // Build the plant with basic properties
            Plant plant = builder
                .buildBasicProperties()
                .build();
            
            // Register observers and add to the ecosystem
            this.environment.registerTimeOfDayObservers(plant);
            this.environment.registerWeatherObservers(plant);
            this.plants.add(plant);
        } catch (IllegalArgumentException e) {
            LoggerMan.log(Level.SEVERE, "Invalid biome name: " + biomeName);
        }
    }
        // Get the appropriate factory for this biome
    public void loadEcosystem(List<AnimalDescriptor> animals, List<PlantDescriptor> plants, String biome) {

        for (AnimalDescriptor animal : animals) {
            this.createAnimal(animal, biome);
        }

        for (PlantDescriptor plant : plants) {
            this.createPlant(plant, biome);
        }
    }

    public MapSize getMapSize() {
        return map.getMapDimensions();
    }

    public Grid getMapGrid() {
        return this.map.getGrid();
    }

    public void populateMap() {
        // Randomly place all organisms on the map during simulation setup
        this.animals.forEach(a -> this.map.initialisePlacement(a));
        this.plants.forEach(p -> this.map.initialisePlacement(p));
    }

    public void updateEnvironmentConditions() {
        // Increment day count first
        this.dayCount++;

        // Check if it's time to change the season (every 5 days)
        if (this.dayCount == 1 || this.dayCount % 5 == 0) {
            this.environment.updateSeason();
        }

        this.environment.updateTimeOfDay();
        this.environment.updateWeather();
    }

    public void setBiome(Biome biome) {
        this.environment.setBiome(biome);
    }

    public List<AnimalDescriptor> getBiomeAnimals() {
        return this.environment.getBiomeAnimals();
    }

    public List<PlantDescriptor> getBiomePlants() {
        return this.environment.getBiomePlants();
    }

    public int getDayCount() {
        return this.dayCount;
    }

    public void updateTimeOfDay() {
        this.environment.updateTimeOfDay();
    }

    public Season getCurrentSeason() {
        return this.environment.getSeason();
    }

    public Weather getCurrentWeather() {
        return this.environment.getWeather();
    }

    public TimeOfDay getCurrentTimeOfDay() {
        return this.environment.getTimeOfDay();
    }

    public int getAnimalCount() {
        return this.animals.size();
    }

    public int getPlantCount() {
        return this.plants.size();
    }

    public List<Animal> getAnimals() {
        return this.animals;
    }

    public List<Plant> getPlants() {
        return this.plants;
    }

    public List<Animal> getDeadAnimals() {
        return this.deadAnimals;
    }

    public List<Plant> getDeadPlants() {
        return this.deadPlants;
    }

    public List<Animal> getNewbornAnimals() {
        return this.newbornAnimals;
    }

    private EcosystemConfig loadConfig() {
        final Optional<EcosystemConfig> fileCfg = FileIO.parseEcosystemConfig();
        if (fileCfg.isEmpty()) {
            LoggerMan.log(Level.SEVERE, "Could not setup ecosystem controller");
            return null;
        }
        return fileCfg.get();
    }

    public void setActionListener(ActionResultListener listener) {
        this.actionListener = listener;
    }


    public int getInitialAnimals() {
        return this.config.initialAnimals();
    }

    public int getInitialPlants() {
        return this.config.initialPlants();
    }

}

</code>

man\EnvironmentMan.java:
<code>
package ecosim.man;


import java.util.List;

import ecosim.attrs.Observer;
import ecosim.enm.Biome;
import ecosim.enm.Season;
import ecosim.enm.TimeOfDay;
import ecosim.enm.Weather;
import ecosim.misc.AnimalDescriptor;
import ecosim.misc.PlantDescriptor;



public class EnvironmentMan {
    private final WeatherMan weatherMan;
    private final SeasonMan seasonMan;
    private final TimeOfDayMan timeOfDayMan;
    private final ChangeMan changeMan;
    private BiomeMan biomeMan;

    public EnvironmentMan() {
        this.changeMan = SimpleChangeMan.getInstance();
        this.timeOfDayMan = new TimeOfDayMan(this.changeMan);
        this.seasonMan = new SeasonMan(this.changeMan);
        this.weatherMan = new WeatherMan(this.changeMan);
    }

    public void setBiome(final Biome biome) {
        this.biomeMan = new BiomeMan(biome);
        this.biomeMan.setupBiome();
    }

    public void updateSeason() {
        this.seasonMan.getNextSeason();
        // load probabilities for new season
        weatherMan.loadWeatherProbabilities(
            this.biomeMan.getBiome(),
            this.seasonMan.getCurrentState());
    }

    public void updateTimeOfDay() {
        this.timeOfDayMan.switchTimeOfDay();
    }

    public void updateWeather() {
        this.weatherMan.updateRandomWeather();
    }

    public Weather getWeather() {
        return this.weatherMan.getCurrentState();
    }

    public Season getSeason() {
        return this.seasonMan.getCurrentState();
    }

    public TimeOfDay getTimeOfDay() {
        return this.timeOfDayMan.getCurrentState();
    }

    public List<AnimalDescriptor> getBiomeAnimals() {
        return this.biomeMan.getAnimals();
    }

    public List<PlantDescriptor> getBiomePlants() {
        return this.biomeMan.getPlants();
    }

    public void registerTimeOfDayObservers(Observer observer) {
        this.timeOfDayMan.attach(observer);
    }

    public void registerSeasonObservers(Observer observer) {
        this.seasonMan.attach(observer);
    }

    public void registerWeatherObservers(Observer observer) {
        this.weatherMan.attach(observer);
    }

}

</code>

man\LoggerMan.java:
<code>
package ecosim.man;


import static ecosim.common.io.ConsoleIO.eprint;

import java.io.IOException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

import ecosim.common.io.FileIO;


public class LoggerMan {
    private static final Logger LOGGER = Logger.getLogger("ecosim");
    private static final String LOG_FILE_DIR = "src/main/java/ecosim/logs";
    private static final String LOG_FILE_PATH = LOG_FILE_DIR + "/ecosim.log";

    private LoggerMan() {
        throw new UnsupportedOperationException("This class cannot be instantiated.");
    }

    static {
        initializeLogger();
    }

    private static void initializeLogger() {
        try {
            if (!FileIO.mkdir(LOG_FILE_DIR)) {
                throw new IOException("Failed to create log directory");
            }

            // Remove any default handlers i.e the console logger
            for (Handler handler : LOGGER.getHandlers()) {
                LOGGER.removeHandler(handler);
            }

            // Disable use of parent handlers to prevent logging to console
            LOGGER.setUseParentHandlers(false);

            FileHandler fileHandler = new FileHandler(LOG_FILE_PATH, true);
            fileHandler.setLevel(Level.ALL);
            fileHandler.setFormatter(new PrettyFormatter());
            LOGGER.addHandler(fileHandler);

            // Set logger level
            LOGGER.setLevel(Level.ALL);
        } catch (IOException e) {
            eprint("Logger setup failed: " + e.getMessage());
        }
    }

    public static void log(Level level, String message, Object... args) {
        LOGGER.log(level, message, args);
    }

    private static class PrettyFormatter extends Formatter {
        private static final DateTimeFormatter DATE_FORMATTER =
            DateTimeFormatter.ISO_INSTANT.withZone(ZoneId.systemDefault());

        @Override
        public String format(LogRecord record) {
            StringBuilder sb = new StringBuilder();

            sb.append("[").append(record.getLevel()).append("] ");
            sb.append("(").append(DATE_FORMATTER.format(Instant.ofEpochMilli(record.getMillis()))).append(") ");
            sb.append(":: ").append(record.getSourceClassName()).append(".").append(record.getSourceMethodName())
                .append(" ");
            sb.append(":: ").append(formatMessage(record)).append(System.lineSeparator());

            return sb.toString();
        }

    }

}

</code>

man\SeasonMan.java:
<code>
package ecosim.man;


import ecosim.attrs.Observable;
import ecosim.enm.Season;
import static ecosim.enm.Season.AUTUMN;
import static ecosim.enm.Season.SPRING;
import static ecosim.enm.Season.SUMMER;
import static ecosim.enm.Season.WINTER;


public class SeasonMan extends Observable {
    private Season currentSeason;

    public SeasonMan(ChangeMan changeManager) {
        // Start the year in Autumn
        super(changeManager);
        this.currentSeason = SUMMER;
    }

    public void getNextSeason() {
        switch (currentSeason) {
            case SPRING -> this.currentSeason = SUMMER;
            case SUMMER -> this.currentSeason = AUTUMN;
            case AUTUMN -> this.currentSeason = WINTER;
            case WINTER -> this.currentSeason = SPRING;
        }
        changeManager.notifyObservers(this);
    }

    @Override
    public Season getCurrentState() {
        return this.currentSeason;
    }

}

</code>

man\SimpleChangeMan.java:
<code>
package ecosim.man;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import ecosim.attrs.Observable;
import ecosim.attrs.Observer;


public class SimpleChangeMan implements ChangeMan {

    private static SimpleChangeMan instance;
    private final Map<Observable, List<Observer>> observableObserverMap = new HashMap<>();

    private SimpleChangeMan() {}

    public static SimpleChangeMan getInstance() {
        if (instance == null) {
            instance = new SimpleChangeMan();
        }
        return instance;
    }

    @Override
    public void register(Observable observable, Observer observer) {
        List<Observer> observers = observableObserverMap.computeIfAbsent(observable, _ -> new ArrayList<>());
        if (!observers.contains(observer)) {
            observers.add(observer);
        }
    }

    @Override
    public void unregister(Observable observable, Observer observer) {
        List<Observer> observers = observableObserverMap.get(observable);
        if (observers != null) {
            observers.remove(observer);
            if (observers.isEmpty()) {
                observableObserverMap.remove(observable);
            }
        }
    }


    @Override
    public void notifyObservers(Observable observable) {
        List<Observer> observers = observableObserverMap.get(observable);
        if (observers != null) {
            for (Observer obs : observers) {
                obs.update(observable);
            }
        }
    }

}

</code>

man\TimeOfDayMan.java:
<code>
package ecosim.man;


import ecosim.attrs.Observable;
import ecosim.enm.TimeOfDay;
import static ecosim.enm.TimeOfDay.DAY;
import static ecosim.enm.TimeOfDay.NIGHT;


public class TimeOfDayMan extends Observable {

    TimeOfDay currentTimeOfDay;

    public TimeOfDayMan(ChangeMan changeManager) {
        // Start time of day at night so that when time switchTimeOfDay is called, it will be day
        super(changeManager);
        this.currentTimeOfDay = NIGHT;
    }

    public void switchTimeOfDay() {
        switch (currentTimeOfDay) {
            case DAY -> this.currentTimeOfDay = NIGHT;
            case NIGHT -> this.currentTimeOfDay = DAY;
        };
        this.changeManager.notifyObservers(this);
    }

    @Override
    public TimeOfDay getCurrentState() {
        return this.currentTimeOfDay;
    }

}

</code>

man\WeatherMan.java:
<code>
package ecosim.man;


import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;

import org.json.JSONException;
import org.json.JSONObject;

import ecosim.attrs.Observable;
import ecosim.enm.Biome;
import ecosim.enm.Season;
import ecosim.enm.Weather;


public class WeatherMan extends Observable {

    private Weather currentWeather;
    private Map<Weather, Double> weatherProbabilities;

    public WeatherMan(ChangeMan changeManager) {
        super(changeManager);
        weatherProbabilities = new HashMap<>();
    }

    @Override
    public Weather getCurrentState() {
        return this.currentWeather;
    }

    public void loadWeatherProbabilities(final Biome biome, final Season season) {
        String biomeName = biome.name();
        String seasonName = season.name();
        Map<Weather, Double> tempProbabilities = new HashMap<>();

        try {
            String content =
                new String(Files.readAllBytes(Paths.get("src/main/resources/json/weather_probabilities.json")));
            JSONObject json = new JSONObject(content);

            if (json.has(biomeName)) {
                JSONObject biomeData = json.getJSONObject(biomeName);
                if (biomeData.has(seasonName)) {
                    JSONObject seasonData = biomeData.getJSONObject(seasonName);
                    for (String key : seasonData.keySet()) {
                        Weather weather = Weather.valueOf(key.toUpperCase());
                        double probability = seasonData.getDouble(key);
                        tempProbabilities.put(weather, probability);
                    }
                } else {
                    LoggerMan.log(Level.WARNING, "Season not found for biome: {0}", seasonName);
                }
            } else {
                LoggerMan.log(Level.WARNING, "Biome not found: {0}", biomeName);
            }
        } catch (IOException | JSONException | IllegalArgumentException e) {
            LoggerMan.log(Level.SEVERE, "Error loading weather probabilities: {0}", e.getMessage());
        }

        this.weatherProbabilities = tempProbabilities;
    }


    public void updateRandomWeather() {
        double random = Math.random();
        double cumulative = 0.0;
        for (Map.Entry<Weather, Double> entry : this.weatherProbabilities.entrySet()) {
            cumulative += entry.getValue();
            if (random <= cumulative) {
                this.currentWeather = entry.getKey();
                changeManager.notifyObservers(this); 
                return;
            }
        }
        this.currentWeather = Weather.CLOUDY; // fallback
        changeManager.notifyObservers(this);
    }
}

</code>

map\ActionResult.java:
<code>
package ecosim.map;

import ecosim.organism.Organism;
import ecosim.organism.animal.abs.Animal;

public class ActionResult {
    public enum ActionType {
        BASIC_ACTION,
        DIED,
        ATTEMPTED_BREEDING,
        SUCCESSFUL_BREEDING,
        ATTEMPTED_EATING,
        SUCCESSFUL_EATING
    }
    
    private final ActionType actionType;
    private final Animal actor;
    private final Animal offspring;
    private final Organism target;
    private final int newX;
    private final int newY;
    
    public ActionResult(ActionType actionType, Animal actor, Organism target, int newX, int newY) {
        this.actionType = actionType;
        this.actor = actor;
        this.target = target;
        this.newX = newX;
        this.newY = newY;
        this.offspring = null;
    }

    public ActionResult(ActionType actionType, Animal actor, Organism target, int newX, int newY, Animal offspring) {
        this.actionType = actionType;
        this.actor = actor;
        this.target = target;
        this.newX = newX;
        this.newY = newY;
        this.offspring = offspring;
    }

    public ActionType getActionType() { return actionType; }
    public Animal getActor() { return actor; }
    public Animal getOffspring() { return offspring;}
    public Organism getTarget() { return target; }
    public int getNewX() { return newX; }
    public int getNewY() { return newY; }
}
</code>

map\Coords.java:
<code>
package ecosim.map;


public class Coords {

    private int x;
    private int y;

    public Coords(final int x, final int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return this.x;
    }

    public int getY() {
        return this.y;
    }

    public void setX(final int x) {
        this.x = x;
    }

    public void setY(final int y) {
        this.y = y;
    }

}

</code>

map\Grid.java:
<code>
package ecosim.map;


import java.util.Optional;

import ecosim.organism.Organism;


/**
 * 2D grid that holds entities (animals & plants).
 *  
 * @author darragh0
 */
public class Grid {

    private final Organism[][] data;

    public Grid(final int width, final int height) {
        this.data = new Organism[height][width];
    }

    public void add(final Organism org) {
        this.data[org.getY()][org.getX()] = org;
    }

    public void rmv(final Organism org) {
        this.data[org.getY()][org.getX()] = null;
    }

    public Optional<Organism> get(final int x, final int y) {
        return Optional.ofNullable(this.data[y][x]);
    }

}

</code>

map\Map.java:
<code>
package ecosim.map;


import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static ecosim.common.Util.randInt;
import static ecosim.common.io.ConsoleIO.pprintln;
import ecosim.enm.Direction;
import ecosim.organism.Organism;
import ecosim.organism.animal.abs.Animal;
import ecosim.organism.plant.abs.Plant;


/**
 * Physical ecosystem of the given dimensions in which
 * organisms (animals & plants) exist together.
 * 
 * @author darragh0
 */
public class Map {

    private static Map inst = null;

    private final int width;
    private final int height;
    private final Grid grid;
    public record MapSize(int width, int height) {};

    private Map(final int width, final int height) {
        this.width = width;
        this.height = height;
        this.grid = new Grid(width, height);
    }

    public static Map init(final int width, final int height) {
        if (inst == null)
            inst = new Map(width, height);
        return inst;
    }

    public static Map getInstance() {
        if (inst == null)
            throw new IllegalStateException("Call Map.init(int, int) first");
        return inst;
    }

    public void add(final Organism org) {
        this.grid.add(org);
    }

    public void initialisePlacement(final Organism org) {
        while (true) {
            final int x = randInt(0, this.width - 1);
            final int y = randInt(0, this.height - 1);

            if (this.get(x, y).isEmpty()) {
                org.setCoords(x, y);
                this.add(org);
                return;
            }
        }
    }

    private void moveAnimalRandomly(Animal an) {
        List<Direction> directions = Arrays.asList(Direction.values());
        Collections.shuffle(directions);
        
        for (Direction dir : directions) {
            int newX = an.getX() + dir.getDx();
            int newY = an.getY() + dir.getDy();
           
            // Check if position is out of bounds
            if (outOfBounds(newX, newY)) {
                continue;
            }
            
            // Check if the position is empty (null means empty space)
            if (canMove(newX, newY) == null) {
                // Found valid empty cell, move there
                moveAnimal(an, newX, newY);
                return;
            }
        }
        // If we get here, no valid moves were found - animal stays put
    }

    public ActionResult getBreedingActionResult(final Animal an, final Organism otherOrg) {
        moveAnimalRandomly(an);
        Animal otherAnimal = (Animal) otherOrg;
    
        Animal offspring = an.breed(otherAnimal);
    
        if (offspring != null) {
            this.initialisePlacement(offspring);
    
            return new ActionResult(
                ActionResult.ActionType.SUCCESSFUL_BREEDING,
                an, otherOrg, an.getX(), an.getY(), offspring);  
        }
        
        return new ActionResult(
            ActionResult.ActionType.ATTEMPTED_BREEDING,
            an, otherOrg, an.getX(), an.getY());
    }

    public ActionResult getEatingActionResult(final Animal predator, final Organism prey, boolean wasEaten) {
        // Move the other animal to a random empty cell
        // Able to do this before the action because an action is guaranteed to happen an is not affected by position at this point
        moveAnimalRandomly(predator);
        if (wasEaten) {
            this.grid.rmv(prey);
            return new ActionResult(
                ActionResult.ActionType.SUCCESSFUL_EATING,
                predator, prey, predator.getX(), predator.getY());
        }
        
        return new ActionResult(
            ActionResult.ActionType.ATTEMPTED_EATING,
            predator, prey, predator.getX(), predator.getY());
    }
    
    public ActionResult move(final Animal an) {
        for (final Direction dir : Direction.values()) {
            int targetX = an.getX() + dir.getDx();
            int targetY = an.getY() + dir.getDy();
    
    
            Organism otherOrg = canMove(targetX, targetY);
            if (otherOrg == null) {
                continue;
            }
    
            // Handle each organism type with a single pattern match
            ActionResult result = switch (otherOrg) {
                case Animal otherAnimal -> {
                    // Check breeding first
                    if (an.canBreed(otherAnimal)) {
                        yield getBreedingActionResult(an, otherAnimal);
                    } 
                    // Then check eating
                    else if (an.canEatAnimal(otherAnimal)) {
                        boolean eaten = an.eat(otherAnimal);
                        yield getEatingActionResult(an, otherAnimal, eaten);
                    }
                
                    yield null;
                }
                case Plant plant -> {
                    // Only check eating for plants
                    if (an.canEatPlant()) {
                        boolean eaten = an.eat(plant);
                        yield getEatingActionResult(an, plant, eaten);
                    }
                    yield null;
                }
                default -> null;
            };

            // If we found a valid action, return it
            if (result != null) {
                return result;
            }
        }
        
        // No valid action found
        moveAnimalRandomly(an);
        return new ActionResult(ActionResult.ActionType.BASIC_ACTION, an, null, an.getX(), an.getY());
    }
    
    private void moveAnimal(Animal an, int newX, int newY) {
        this.grid.rmv(an);
        an.setCoords(newX, newY);
        this.grid.add(an);
    }

    public void display() {
        pprintln(this.toString());
    }

    public MapSize getMapDimensions() {
        return new MapSize(this.width, this.height);
    }

    public Grid getGrid() {
        return this.grid;
    }

    Optional<Organism> get(final int x, final int y) {
        return this.grid.get(x, y);
    }

    private boolean outOfBounds(final int x, final int y) {
        return x < 0 || x >= this.width || y < 0 || y >= this.height;
    }

    private Organism canMove(final int x, final int y) {
        if (!this.outOfBounds(x, y)){
            Optional<Organism> cell = this.get(x, y);
            if (cell.isPresent()) {
                return cell.get();
            } else {
                return null;
            }
        }
        return null;
    }

}

</code>

menu\AnimalMenu.java:
<code>
package ecosim.menu;


import java.util.List;


/**
 * Menu for selecting animal species.
 * 
 * @author darragh0
 */
public class AnimalMenu extends OrganismMenu<String> {

    public AnimalMenu(final List<String> animalNames) {
        super("Available Animals", animalNames);
    }

}

</code>

menu\BiomeMenu.java:
<code>
package ecosim.menu;


import java.util.List;

import ecosim.enm.Biome;


/**
 * Menu for selecting biome.
 * 
 * @author darragh0
 */
public class BiomeMenu extends Menu<Biome> {

    public BiomeMenu(final List<Biome> options) {
        super("Available Biomes", options);
    }

    public BiomeMenu(final Biome... options) {
        this(List.of(options));
    }

}

</code>

menu\Menu.java:
<code>
package ecosim.menu;


import static ecosim.common.io.ConsoleIO.eprint;
import static ecosim.common.io.ConsoleIO.notInRange;
import static ecosim.common.io.ConsoleIO.pprintln;
import static ecosim.common.io.ConsoleIO.strInput;

import java.util.ArrayList;
import java.util.List;
import java.util.OptionalInt;
import java.util.stream.IntStream;

import ecosim.common.Util;


/**
 * Base class for all menus in the Ecosim application.
 * 
 * @param <T> The type of options in the menu (e.g. `String`)
 * @author darragh0
 */
public abstract class Menu<T> {

    protected final String heading;
    protected final List<T> options;
    protected final List<String> optionStrings;

    protected Menu(final String heading, final List<T> options) {
        this.heading = heading;
        this.options = new ArrayList<>(options);
        this.optionStrings = this.options.stream().map(this::optionToString).toList();
    }

    public void print() {
        pprintln("[flg:%s]", this.heading);
        System.out.println("=".repeat(this.heading.length() + 2));

        for (int i = 0; i < this.options.size(); i++) {
            pprintln("([fly:%d]) [flc:%s]", i + 1, this.optionStrings.get(i));
        }
        System.out.println();
    }

    protected String optionToString(final T option) {
        return option.toString();
    }

    public T getUserChoice(final String prompt) {

        while (true) {
            String strIn = strInput(prompt);
            OptionalInt intIn = Util.parseInt(strIn);

            if (intIn.isPresent()) {
                int num = intIn.getAsInt();
                if (notInRange(num, 1, this.options.size())) {
                    eprint("Enter a number between 1-%d", this.options.size());
                    continue;
                }
                return this.options.get(num - 1);
            }

            OptionalInt index = IntStream.range(0, this.optionStrings.size())
                .filter(i -> this.optionStrings.get(i).equalsIgnoreCase(strIn))
                .findFirst();

            if (index.isPresent())
                return this.options.get(index.getAsInt());

            eprint("Invalid input");
        }
    }

    public T getUserChoice() {
        return this.getUserChoice("Enter your choice >> ");
    }

}

</code>

menu\OrganismMenu.java:
<code>
package ecosim.menu;


import java.util.List;


/**
 * Base menu for selecting organism species.
 * 
 * @author darragh0
 */
public abstract class OrganismMenu<T> extends Menu<T> {

    public OrganismMenu(final String heading, final List<T> options) {
        super(heading, options);
    }

}

</code>

menu\PlantMenu.java:
<code>
package ecosim.menu;


import java.util.List;


/**
 * Menu for selecting plant species.
 * 
 * @author darragh0
 */
public class PlantMenu extends OrganismMenu<String> {

    public PlantMenu(final List<String> plantNames) {
        super("Available Plants", plantNames);
    }

}

</code>

misc\AnimalDescriptor.java:
<code>
package ecosim.misc;

import ecosim.enm.ActivityType;
import ecosim.enm.Diet;
import ecosim.enm.Size;

public record AnimalDescriptor(
    String name,
    Size size,
    Diet diet,
    ActivityType activityType,
    boolean canHibernate,
    String sound,
    String symbol) implements Descriptor {
}
</code>

misc\Descriptor.java:
<code>
package ecosim.misc;


import ecosim.enm.Size;


public interface Descriptor {

    Size size();

    String symbol();

}

</code>

misc\EcosystemConfig.java:
<code>
package ecosim.misc;


public record EcosystemConfig(int initialAnimals, int initialPlants) {
}

</code>

misc\PlantDescriptor.java:
<code>
package ecosim.misc;

import ecosim.enm.Size;

public record PlantDescriptor(
    String name,
    Size size,
    String symbol) implements Descriptor {
}
</code>

misc\SpeciesNumbering.java:
<code>
package ecosim.misc;

import java.util.HashMap;
import java.util.Map;

/**
 * Central service for managing species numbering across the ecosystem.
 */
public class SpeciesNumbering {
    private static final Map<String, Integer> speciesCounter = new HashMap<>();
    
    /**
     * Gets the next number for a given species name.
     * 
     * @param speciesName The base name of the species
     * @return The next sequential number for this species
     */
    public static synchronized int getNextNumber(String speciesName) {
        // Add null check to prevent NullPointerException
        if (speciesName == null) {
            return 1;  // Default to 1 for null species names
        }
        
        // Trim the species name to handle any whitespace
        speciesName = speciesName.trim();
        
        int nextNumber = speciesCounter.getOrDefault(speciesName, 0) + 1;
        speciesCounter.put(speciesName, nextNumber);
        return nextNumber;
    }
    
    /**
     * Formats a species name with its number.
     * 
     * @param speciesName The base name of the species
     * @param number The instance number
     * @return Formatted name like "Lion (3)"
     */
    public static String formatName(String speciesName, int number) {
        // Add null check to prevent NullPointerException
        if (speciesName == null) {
            return "Unknown (" + number + ")";
        }
        
        return speciesName.trim() + " (" + number + ")";
    }
    
    /**
     * Extracts the base species name from a formatted name.
     * 
     * @param formattedName The formatted name like "Lion (3)"
     * @return The base species name like "Lion"
     */
    public static String extractBaseSpeciesName(String formattedName) {
        if (formattedName == null) {
            return "Unknown";
        }
        
        int openParenIndex = formattedName.indexOf('(');
        if (openParenIndex > 0) {
            return formattedName.substring(0, openParenIndex).trim();
        }
        return formattedName.trim();
    }
    
    /** 
    * Generates a new name for a cloned organism based on the parent's name.
    * This method extracts the base name from the parent, gets the next number
    * for this species type, and formats a new name accordingly.
    *
    * @param parentName The name of the parent organism
    * @return A new name for the cloned organism
    */
   public static String generateCloneName(String parentName) {
       // Extract base species name
       String baseName = extractBaseSpeciesName(parentName);
       // Get next number for this species
       int nextNumber = getNextNumber(baseName);
       // Format name with base and number
       return formatName(baseName, nextNumber);
   }
}
</code>

organism\Organism.java:
<code>
package ecosim.organism;


import ecosim.attrs.Movable;
import ecosim.enm.Size;


/**
 * Physical animal or plant entity.
 * 
 * @author darragh0
 */
public abstract class Organism extends Movable {

    protected String symbol;
    protected Size size;

    protected float health;
    protected String name;

    public Organism() {
    }
    public Organism(final String name) {
        this.name = name;
    }

    public abstract Organism clone();

    public Organism setSymbol(String symbol) {
        this.symbol = symbol;
        return this;
    }

    public Organism setName(String name) {
        this.name = name;
        return this;
    }

    public void getName(String name) {
        this.name = name;
    }

    public String getSymbol() {
        return this.symbol;
    }

    public Organism setSize(Size size) {
        this.size = size;
        this.health = this.getMaxHealth() / 2;
        return this;
    }

    public Size getSize() {
        return this.size;
    }

    public String getName() {
        return name;
    }

    public float getHealth() {
        return this.health;
    }

    public float getNutritionalValue() {
        return this.size.getNutritionalValue();
    }

    public float getMaxHealth() {
        return this.size.getMaxHealth();
    }

}

</code>

organism\animal\abs\Animal.java:
<code>
package ecosim.organism.animal.abs;


import ecosim.attrs.Observable;
import ecosim.attrs.Observer;
import ecosim.enm.ActivityState;
import ecosim.enm.ActivityType;
import ecosim.enm.Diet;
import ecosim.enm.Event;
import ecosim.enm.Season;
import ecosim.enm.Size;
import ecosim.enm.TimeOfDay;
import ecosim.map.ActionResult;
import ecosim.organism.Organism;
import ecosim.organism.animal.animal_state.AnimalState;
import ecosim.organism.animal.animal_state.AwakeState;
import ecosim.organism.plant.abs.Plant;


/**
 * Abstract class representing an animal in the ecosystem,
 * defining its properties, behaviors, and interactions.
 * 
 * @author jjola00
 */
public abstract class Animal extends Organism implements Observer {


    protected Diet diet;
    protected ActivityType activityType;
    protected boolean canHibernate;
    protected String sound;

    protected float survivalChance;
    protected float reproductiveChance;
    protected AnimalState state;

    public Animal() {
        this.state = new AwakeState();
        this.survivalChance = 0.5f;
        this.reproductiveChance = 0.5f;
    }

    public Animal(Animal animal) {
        super(animal.name);
        this.state = new AwakeState();
        this.symbol = animal.symbol;
        this.size = animal.size;
        this.canHibernate = animal.canHibernate;
        this.diet = animal.diet;
        this.activityType = animal.activityType;
        this.survivalChance = animal.survivalChance;
        this.reproductiveChance = animal.reproductiveChance;
    }

    @Override
    public Animal setSymbol(String symbol) {
        super.setSymbol(symbol);
        return this;
    }

    @Override
    public Animal setSize(Size size) {
        super.setSize(size);
        return this;
    }

    public Animal setDiet(Diet diet) {
        this.diet = diet;
        return this;
    }

    public Diet getDiet() {
        return this.diet;
    }

    public Animal setActivityType(ActivityType activityType) {
        this.activityType = activityType;
        return this;
    }
    public ActivityType getActivityType() {
        return this.activityType;
    }

    public Animal setCanHibernate(boolean canHibernate) {
        this.canHibernate = canHibernate;
        return this;
    }

    public boolean canHibernate() {
        return this.canHibernate;
    }

    public Animal setSound(String sound) {
        this.sound = sound;
        return this;
    }

    @Override
    public Animal setName(String name) {
        this.name = name;
        return this;
    }
    public String getSound() {
        return this.sound;
    }

    public void setHealth(float health) {
        this.health = health;
    }

    public float getSurvivalChance() {
        return this.survivalChance;
    }

    public float getReproductiveChance() {
        return this.reproductiveChance;
    }

    public boolean canEatAnimal(Animal potentialPrey) {
        boolean isDietCompatible = this.diet != Diet.HERBIVORE;
        boolean isDifferentSpecies = !this.canBreed(potentialPrey);
        boolean isPredatorLargeEnough = this.size.ordinal() >= potentialPrey.size.ordinal();

        return isDietCompatible && isDifferentSpecies && isPredatorLargeEnough;
    }

    public boolean canBreed(Animal potentialMate) {
        // Extract the base type from both animal names
        String thisBaseType = extractBaseType(this.getName());
        String mateBaseType = extractBaseType(potentialMate.getName());

        // Compare the base types
        return thisBaseType.equals(mateBaseType);
    }

    // Helper method to extract the base animal type from the name
    private String extractBaseType(String name) {
        // Extract the base name (e.g., "Lion" from "Lion (1)")
        int parenthesisIndex = name.indexOf('(');
        if (parenthesisIndex > 0) {
            return name.substring(0, parenthesisIndex).trim();
        }
        return name.trim();
    }


    public boolean canEatPlant() {
        return this.diet != Diet.CARNIVORE;
    }

    public boolean eat(Animal animal) {
        if (Math.random() < animal.survivalChance) {
            this.restoreHealth(animal.getNutritionalValue());
            return true;
        }
        return false;
    };

    public boolean eat(Plant plant) {
        this.restoreHealth(plant.getNutritionalValue());
        plant.beEaten();
        return true;
    };

    public Animal breed(Animal mate) {
        float combinedReproductiveChance = this.reproductiveChance * mate.reproductiveChance;

        if (Math.random() < combinedReproductiveChance)
            return this.createClone();
        return null;
    }

    @Override
    public abstract Animal clone();

    public Animal createClone() {
        Animal clone = clone();
        clone.symbol = this.symbol;
        clone.setSize(this.size);
        clone.diet = this.diet;
        clone.activityType = this.activityType;
        clone.canHibernate = this.canHibernate;
        return clone;
    }

    public ActionResult move() {
        // Delegate to the current state
        return this.state.move(this);
    }

    @Override
    public void update(Observable observable) {
        Event event = observable.getCurrentState();
        switch (event) {
            case Season season -> handleSeasonUpdate(season);
            case TimeOfDay timeOfDay -> handleTimeOfDayUpdate(timeOfDay);
            default -> {
            }
        }
    }

    public void handleSeasonUpdate(Season season) {
        AnimalState newState = this.state.handleSeasonChange(this, season);
        if (newState != this.state) {
            this.state = newState;
        }
    }

    public void handleTimeOfDayUpdate(TimeOfDay timeOfDay) {
        AnimalState newState = this.state.handleTimeOfDayChange(this, timeOfDay);
        if (newState != this.state) {
            this.state = newState;
        }
    }

    public ActivityState getActivityState() {
        return this.state.getActivityState();
    }

    public boolean isEdible(Organism organism) {
        return false;
    }

    public void reduceHealth(float amount) {
        this.health = Math.max(0, this.health - amount);
    }

    public void restoreHealth(float amount) {
        this.health = Math.min(this.getMaxHealth(), this.health + amount);
    }

}
</code>

organism\animal\animal_state\AnimalState.java:
<code>
package ecosim.organism.animal.animal_state;


import ecosim.enm.ActivityState;
import ecosim.enm.Season;
import ecosim.enm.TimeOfDay;
import ecosim.map.ActionResult;
import ecosim.organism.animal.abs.Animal;


/**
 * Interface representing the conscious state of an animal,
 * defining the movement behavior for different states.
 * 
 * @author jjola00
 */

public interface AnimalState {
   
    ActionResult move(Animal animal);
    
    AnimalState handleSeasonChange(Animal animal, Season season);
    
    AnimalState handleTimeOfDayChange(Animal animal, TimeOfDay timeOfDay);

    ActivityState getActivityState();
}
</code>

organism\animal\animal_state\AwakeState.java:
<code>
package ecosim.organism.animal.animal_state;


import ecosim.enm.ActivityState;
import ecosim.enm.ActivityType;
import ecosim.enm.Season;
import ecosim.enm.TimeOfDay;
import ecosim.map.ActionResult;
import ecosim.map.Map;
import ecosim.organism.animal.abs.Animal;


/**
 * Represents the conscious state of an animal,
 * defining its movement behavior within the ecosystem.
 * 
 * @author jjola00
 */
public class AwakeState implements AnimalState {

    @Override
    public ActionResult move(Animal animal) {

        return Map.getInstance().move(animal);
    }

    @Override
    public AnimalState handleSeasonChange(Animal animal, Season season) {
        switch (season) {
                    case WINTER -> {
                        if (animal.canHibernate()) {
                            return new HibernatingState();
                        }
                    }
                    default -> {} // Do nothing

        }
        return this; // Stay awake
    }

    @Override
    public AnimalState handleTimeOfDayChange(Animal animal, TimeOfDay timeOfDay) {
        ActivityType activityType = animal.getActivityType();
        
        if ((timeOfDay == TimeOfDay.DAY && activityType != ActivityType.DIURNAL) || 
            (timeOfDay == TimeOfDay.NIGHT && activityType != ActivityType.NOCTURNAL)) {
            return new SleepingState();
        }
        
        return this; // Stay awake
    }

     @Override
    public ActivityState getActivityState() {
        return ActivityState.AWAKE;
    }
}
    


</code>

organism\animal\animal_state\HibernatingState.java:
<code>
package ecosim.organism.animal.animal_state;

import ecosim.enm.ActivityState;
import ecosim.enm.Season;
import ecosim.enm.TimeOfDay;
import ecosim.map.ActionResult;
import ecosim.organism.animal.abs.Animal;

public class HibernatingState implements AnimalState {

    @Override
    public ActionResult move(Animal animal) {
        float healthRecovery = animal.getMaxHealth() * 0.1f;
        if (animal.getHealth() < animal.getMaxHealth()) {
            animal.restoreHealth(healthRecovery);
        }

        return new ActionResult(
            ActionResult.ActionType.BASIC_ACTION,
            animal,
            null,
            animal.getX(),
            animal.getY()
        );
    }


    @Override
    public AnimalState handleSeasonChange(Animal animal, Season season) {
        switch (season) {
                    case SPRING, SUMMER, AUTUMN -> {
                        if (animal.canHibernate()) {
                            return new AwakeState();
                        }
                    }
                    default -> {} // Do nothing

        }
        return this; // hibernating
    }
    @Override
    public AnimalState handleTimeOfDayChange(Animal animal, TimeOfDay timeOfDay) {
       return this; // Stay hibernating
    }

    @Override
    public ActivityState getActivityState() {
        return ActivityState.HIBERNATING;
    }
    
}
</code>

organism\animal\animal_state\SleepingState.java:
<code>
package ecosim.organism.animal.animal_state;

import ecosim.enm.ActivityState;
import ecosim.enm.ActivityType;
import ecosim.enm.Season;
import ecosim.enm.TimeOfDay;
import ecosim.map.ActionResult;
import ecosim.organism.animal.abs.Animal;

public class SleepingState  implements AnimalState{

    @Override
    public ActionResult move(Animal animal) {
        float healthRecovery = animal.getMaxHealth() * 0.05f;
        if (animal.getHealth() < animal.getMaxHealth()) {
            animal.restoreHealth(healthRecovery);
        }

        return new ActionResult(
            ActionResult.ActionType.BASIC_ACTION,
            animal,
            null,
            animal.getX(),
            animal.getY()
        );
    }

    @Override
    public AnimalState handleSeasonChange(Animal animal, Season season) {
        switch (season) {
                    case WINTER -> {
                        if (animal.canHibernate()) {
                            return new HibernatingState();
                        }
                    }
                    default -> {} // Do nothing

        }
        return this; // Stay asleep
    }

     @Override
    public AnimalState handleTimeOfDayChange(Animal animal, TimeOfDay timeOfDay) {
        ActivityType activityType = animal.getActivityType();
        
        if ((timeOfDay == TimeOfDay.DAY && activityType == ActivityType.DIURNAL) || 
            (timeOfDay == TimeOfDay.NIGHT && activityType == ActivityType.NOCTURNAL)) {
            return new AwakeState();
        }
        
        return this; // Stay asleep
    }


    @Override
    public ActivityState getActivityState() {
        return ActivityState.SLEEPING;
    }
    
}
</code>

organism\animal\concrete\DesertAnimal.java:
<code>
package ecosim.organism.animal.concrete;

import ecosim.enm.ActivityState;
import ecosim.map.ActionResult;
import ecosim.misc.SpeciesNumbering;
import ecosim.organism.animal.abs.Animal;

public class DesertAnimal extends Animal {

    @Override
    public ActionResult move() {
        if (this.state.getActivityState() == ActivityState.AWAKE) {
            float healthLoss = this.getMaxHealth() * 0.025f;
            this.reduceHealth(healthLoss);
        }
        
        return this.state.move(this);
    }

    @Override
    public Animal clone() {
        DesertAnimal clone = new DesertAnimal();
        clone.setName(SpeciesNumbering.generateCloneName(this.getName()));
        return clone;
    }
}
</code>

organism\animal\concrete\GrasslandAnimal.java:
<code>
package ecosim.organism.animal.concrete;

import ecosim.enm.ActivityState;
import ecosim.map.ActionResult;
import ecosim.misc.SpeciesNumbering;
import ecosim.organism.animal.abs.Animal;

public class GrasslandAnimal extends Animal {

    @Override
    public ActionResult move() {
        if (this.state.getActivityState() == ActivityState.AWAKE) {
            float healthLoss = this.getMaxHealth() * 0.025f;
            this.reduceHealth(healthLoss);
        }
        
        return this.state.move(this);
    }

    @Override
    public Animal clone() {
        // Extract base species name
         String baseName = SpeciesNumbering.extractBaseSpeciesName(getName());
         // Get next number for this species
         int nextNumber = SpeciesNumbering.getNextNumber(baseName);
         
        GrasslandAnimal clone = new GrasslandAnimal();
        clone.setName(SpeciesNumbering.formatName(baseName, nextNumber));
        return clone;
    }
    
}
</code>

organism\animal\decorator\AnimalDecorator.java:
<code>
package ecosim.organism.animal.decorator;


import ecosim.organism.animal.abs.Animal;


/**
 * Abstract class for decorating animals, allowing for
 * additional behaviors or properties to be added.
 * 
 * @author jjola00
 */
public abstract class AnimalDecorator extends Animal {

    protected final Animal animal;

    public AnimalDecorator(final Animal animal) {
        super(animal);
        this.animal = animal;
    } 

    @Override
    public String getSound(){
        return animal.getSound();
    }

}

</code>

organism\animal\decorator\ConservationBoostDecorator.java:
<code>
package ecosim.organism.animal.decorator;


import ecosim.organism.animal.abs.Animal;


/**
 * Decorator class that enhances the health conservation
 * of an animal when it moves.
 * 
 * @author jjola00
 */
public class ConservationBoostDecorator extends AnimalDecorator {
    public ConservationBoostDecorator(Animal animal) {
        super(animal);
    }

    @Override
    public void reduceHealth(float amount) {
        super.reduceHealth(amount * 0.5f);
    }

    @Override
    public Animal clone() {
        return new ConservationBoostDecorator(animal.clone());
    }

}

</code>

organism\animal\decorator\FertilityBoostDecorator.java:
<code>
package ecosim.organism.animal.decorator;


import ecosim.organism.animal.abs.Animal;


/**
 * Decorator class that enhances the reproductive chance
 * of an animal, indicating high fertility.
 * 
 * @author jjola00
 */
public class FertilityBoostDecorator extends AnimalDecorator {

    public FertilityBoostDecorator(Animal animal) {
        super(animal);
        this.reproductiveChance += 0.2f;
    }

    @Override
    public Animal clone() {
        return new FertilityBoostDecorator(animal.clone());
    }

}

</code>

organism\animal\decorator\SurvivabilityBoostDecorator.java:
<code>
package ecosim.organism.animal.decorator;


import ecosim.organism.animal.abs.Animal;


/**
 * Decorator class that enhances the survival chance
 * of an animal, indicating high survivability.
 * 
 * @author jjola00
 */
public class SurvivabilityBoostDecorator extends AnimalDecorator {

    public SurvivabilityBoostDecorator(Animal animal) {
        super(animal);
        this.survivalChance += 0.2f;
    }

    @Override
    public Animal clone() {
        return new SurvivabilityBoostDecorator(animal.clone());
    }

}

</code>

organism\builder\AbstractAnimalBuilder.java:
<code>
package ecosim.organism.builder;

import ecosim.common.Util;
import ecosim.misc.AnimalDescriptor;
import ecosim.organism.animal.abs.Animal;
import ecosim.organism.animal.decorator.ConservationBoostDecorator;
import ecosim.organism.animal.decorator.FertilityBoostDecorator;
import ecosim.organism.animal.decorator.SurvivabilityBoostDecorator;

/**
 * Abstract implementation of the AnimalBuilder with common functionality.
 */
public abstract class AbstractAnimalBuilder implements AnimalBuilder {
    protected AnimalDescriptor descriptor;
    protected Animal animal;
    
    public AbstractAnimalBuilder(AnimalDescriptor descriptor) {
        this.descriptor = descriptor;
        initializeAnimal();
    }

    /**
     * Initializes the animal instance.
     */
    private void initializeAnimal() {
        this.animal = createAnimalInstance();
    }

    /**
     * Creates the appropriate animal instance for this builder.
     * Each specific builder must implement this to create the right type.
     * 
     * @return A new animal instance of the appropriate biome type
     */
    protected abstract Animal createAnimalInstance();
    
    @Override
    public AnimalBuilder buildBasicProperties() {

        String speciesName = descriptor.name();
    
        // Get the next number for this species
        int number = ecosim.misc.SpeciesNumbering.getNextNumber(speciesName);
        
        // Format the name with the number
        String formattedName = ecosim.misc.SpeciesNumbering.formatName(speciesName, number);
        animal.setName(formattedName)
              .setSize(descriptor.size())
              .setDiet(descriptor.diet())
              .setActivityType(descriptor.activityType())
              .setCanHibernate(descriptor.canHibernate())
              .setSound(descriptor.sound())
              .setSymbol(descriptor.symbol());
        return this;
    }
    
    @Override
    public AnimalBuilder applyDecorators() {
        int randomDecorator = Util.randInt(0, 4);
        switch (randomDecorator) {
            case 0 -> animal = new ConservationBoostDecorator(animal);
            case 1 -> animal = new FertilityBoostDecorator(animal);
            case 2 -> animal = new SurvivabilityBoostDecorator(animal);
            default -> {
            }
        }
        
        return this;
    }
    
    @Override
    public Animal build() {
        return animal;
    }
}

</code>

organism\builder\AbstractPlantBuilder.java:
<code>
package ecosim.organism.builder;

import ecosim.misc.PlantDescriptor;
import ecosim.organism.plant.abs.Plant;

public abstract class AbstractPlantBuilder implements PlantBuilder {
    protected PlantDescriptor descriptor;
    protected Plant plant;
    /**
     * Creates a builder with the provided descriptor.
     * 
     * @param descriptor The descriptor containing plant specifications
     */
    public AbstractPlantBuilder(PlantDescriptor descriptor) {
        this.descriptor = descriptor;
        initializePlant();
    }
    
    /**
     * Initializes the plant instance.
     */
    private void initializePlant() {
        this.plant = createPlantInstance();
    }

     /**
     * Creates the appropriate plant instance for this builder.
     * Each specific builder must implement this to create the right type.
     * 
     * @return A new plant instance of the appropriate biome type
     */
    protected abstract Plant createPlantInstance();
    
    @Override
    public PlantBuilder buildBasicProperties() {
           // Get the species name from the descriptor
    String speciesName = descriptor.name();
    
    // Get the next number for this species
    int number = ecosim.misc.SpeciesNumbering.getNextNumber(speciesName);
    
    // Format the name with the number
    String formattedName = ecosim.misc.SpeciesNumbering.formatName(speciesName, number);
    
    // Set properties directly from descriptor but use formatted name
    plant.setName(formattedName)
             .setSymbol(descriptor.symbol())
             .setSize(descriptor.size());
             
        return this;
    }

      @Override
    public Plant build() {
        return plant;
    }
    
}

</code>

organism\builder\AnimalBuilder.java:
<code>
package ecosim.organism.builder;

import ecosim.organism.animal.abs.Animal;

/**
 * Builder interface for creating animals with flexible configuration.
 */
public interface AnimalBuilder {
    /**
     * Builds the basic properties of the animal.
     * 
     * @return This builder for method chaining
     */
    AnimalBuilder buildBasicProperties();
    
    /**
     * Applies any decorator enhancements to the animal.
     * 
     * @return This builder for method chaining
     */
    AnimalBuilder applyDecorators();
    
       /**
     * Creates the animal instance.
     * 
     * @return A fully constructed animal
     */
    Animal build();
}
    
</code>

organism\builder\DesertAnimalBuilder.java:
<code>
package ecosim.organism.builder;

import ecosim.misc.AnimalDescriptor;
import ecosim.organism.animal.abs.Animal;
import ecosim.organism.animal.concrete.DesertAnimal;

/**
 * Concrete builder for desert animals.
 */
public class DesertAnimalBuilder extends AbstractAnimalBuilder {
    
    public DesertAnimalBuilder(AnimalDescriptor descriptor) {
        super(descriptor);
    }
    
    @Override
    protected Animal createAnimalInstance() {
    
        return new DesertAnimal();
    }
}


</code>

organism\builder\DesertPlantBuilder.java:
<code>
package ecosim.organism.builder;

import ecosim.misc.PlantDescriptor;
import ecosim.organism.plant.abs.Plant;
import ecosim.organism.plant.concrete.DesertPlant;

public class DesertPlantBuilder extends AbstractPlantBuilder {
        
    /**
     * Creates a new desert plant builder.
     * 
     * @param descriptor The plant descriptor
     */
    public DesertPlantBuilder(PlantDescriptor descriptor) {
        super(descriptor);
    }

    @Override
    protected Plant createPlantInstance() {
        return new DesertPlant();
    }
    
}

</code>

organism\builder\GrasslandAnimalBuilder.java:
<code>
package ecosim.organism.builder;

import ecosim.misc.AnimalDescriptor;
import ecosim.organism.animal.abs.Animal;
import ecosim.organism.animal.concrete.GrasslandAnimal;

/**
 * Concrete builder for grassland animals.
 */
public class GrasslandAnimalBuilder extends AbstractAnimalBuilder {
    
    public GrasslandAnimalBuilder(AnimalDescriptor descriptor) {
        super(descriptor);
    }

    @Override
    protected Animal createAnimalInstance() {
        return new GrasslandAnimal();
    }

    
    

}
</code>

organism\builder\GrasslandPlantBuilder.java:
<code>
package ecosim.organism.builder;

import ecosim.misc.PlantDescriptor;
import ecosim.organism.plant.abs.Plant;
import ecosim.organism.plant.concrete.GrasslandPlant;

public class GrasslandPlantBuilder extends AbstractPlantBuilder {
      
    /**
     * Creates a new grassland plant builder.
     * 
     * @param descriptor The plant descriptor
     */
    public GrasslandPlantBuilder(PlantDescriptor descriptor) {
        super(descriptor);
    }

    @Override
    protected Plant createPlantInstance() {
        return new GrasslandPlant();
    }
    
}

</code>

organism\builder\PlantBuilder.java:
<code>
package ecosim.organism.builder;

import ecosim.organism.plant.abs.Plant;

/**
 * Builder interface for creating plants with flexible configuration.
 */
public interface PlantBuilder {
    /**
     * Builds the basic properties of the plant.
     * 
     * @return This builder for method chaining
     */
    PlantBuilder buildBasicProperties();
    
    /**
     * Creates the plant instance.
     * 
     * @return A fully constructed plant
     */
    Plant build();
}
</code>

organism\factory\BiomeOrganismFactory.java:
<code>

package ecosim.organism.factory;

import ecosim.misc.AnimalDescriptor;
import ecosim.misc.PlantDescriptor;
import ecosim.organism.builder.AnimalBuilder;
import ecosim.organism.builder.PlantBuilder;

public interface BiomeOrganismFactory {
    /**
     * Creates an animal builder for the specific biome.
     * 
     * @param descriptor The descriptor containing the animal specifications
     * @return An animal builder
     */
    AnimalBuilder createAnimalBuilder(AnimalDescriptor descriptor);
    
    /**
     * Creates a plant builder for the specific biome.
     * 
     * @param descriptor The descriptor containing the plant specifications
     * @return A plant builder
     */
    PlantBuilder createPlantBuilder(PlantDescriptor descriptor);
    
}
</code>

organism\factory\BiomeOrganismFactoryProvider.java:
<code>
package ecosim.organism.factory;

import ecosim.enm.Biome;

/**
 * Provider for biome-specific organism factories.
 */
public class BiomeOrganismFactoryProvider {
    
    /**
     * Get the appropriate factory for the specified biome.
     * 
     * @param biome The biome to get a factory for
     * @return A factory instance for the biome
     */
    public static BiomeOrganismFactory getFactory(Biome biome) {
        return switch (biome) {
            case DESERT -> new DesertOrganismFactory();
            case GRASSLAND -> new GrasslandOrganismFactory();
            default -> throw new IllegalArgumentException("Unsupported biome: " + biome);
        };
    }
}
</code>

organism\factory\DesertOrganismFactory.java:
<code>
package ecosim.organism.factory;

import ecosim.misc.AnimalDescriptor;
import ecosim.misc.PlantDescriptor;
import ecosim.organism.builder.AnimalBuilder;
import ecosim.organism.builder.DesertAnimalBuilder;
import ecosim.organism.builder.DesertPlantBuilder;
import ecosim.organism.builder.PlantBuilder;

public class DesertOrganismFactory implements BiomeOrganismFactory {

    @Override
    public AnimalBuilder createAnimalBuilder(AnimalDescriptor descriptor) {
        return new DesertAnimalBuilder(descriptor);
    }
    
    @Override
    public PlantBuilder createPlantBuilder(PlantDescriptor descriptor) {
        return new DesertPlantBuilder(descriptor);
    }
    
}

</code>

organism\factory\GrasslandOrganismFactory.java:
<code>
package ecosim.organism.factory;

import ecosim.misc.AnimalDescriptor;
import ecosim.misc.PlantDescriptor;
import ecosim.organism.builder.AnimalBuilder;
import ecosim.organism.builder.GrasslandAnimalBuilder;
import ecosim.organism.builder.GrasslandPlantBuilder;
import ecosim.organism.builder.PlantBuilder;

public class GrasslandOrganismFactory implements BiomeOrganismFactory {
    
    @Override
    public AnimalBuilder createAnimalBuilder(AnimalDescriptor descriptor) {
        return new GrasslandAnimalBuilder(descriptor);
    }
    
    @Override
    public PlantBuilder createPlantBuilder(PlantDescriptor descriptor) {
        return new GrasslandPlantBuilder(descriptor);
    }
}
</code>

organism\plant\abs\Plant.java:
<code>
package ecosim.organism.plant.abs;

import ecosim.attrs.Observable;
import ecosim.attrs.Observer;
import ecosim.enm.Event;
import ecosim.enm.Size;
import ecosim.enm.TimeOfDay;
import ecosim.enm.Weather;
import ecosim.organism.Organism;
import ecosim.organism.plant.energy_cycle_state.EnergyCycleState;
import ecosim.organism.plant.energy_cycle_state.PhotosynthesisState;

/**
 * Abstract base class for all plants in the ecosystem simulation.
 * 
 * This class implements core plant functionality including:
 * - Energy cycle management (photosynthesis/respiration)
 * - Growth rate calculations based on environmental factors
 * - Health management and its impact on other plant functions
 * - Reproduction through asexual reproduction
 * - Response to being eaten by herbivores
 * - Environmental event observation (weather, time of day)
 * 
 * @author MiaBorkoo
 */
public abstract class Plant extends Organism implements Observer {

    /** Number of bites a plant can withstand before being completely consumed */
    protected int biteCapacity;
    
    /** Divisor used to calculate bite damage as a fraction of max health */
    private static final int BITE_DIVISOR = 10;
    
    /** Current energy cycle state (photosynthesis during day, respiration at night) */
    protected EnergyCycleState energyCycleState;
    
    /** Current growth rate, affected by weather and health */
    protected float growthRate;

    /** Health threshold below which the plant is considered dead */
    private static final float HEALTH_THRESHOLD = 0.0f;

    public Plant() {
      this.energyCycleState = new PhotosynthesisState();
    }

    /**
     * Sets the size of the plant and calculates bite capacity based on max health.
     * 
     * @param size The size to set for this plant
     * @return 
     */
    @Override
    public Plant setSize(Size size) {
        super.setSize(size);
        this.biteCapacity = this.size.getMaxHealth() / BITE_DIVISOR;
        return this;
    }

    /**
     * Sets the display symbol for this plant.
     * 
     * @param symbol The symbol to represent this plant
     * @return This plant instance (for method chaining)
     */
    @Override
    public Plant setSymbol(String symbol) {
        super.setSymbol(symbol);
        return this;
    }

    /**
     * Updates growth rate based on current weather conditions.
     * Different plant types respond differently to weather.
     * 
     * @param weather Current weather condition
     */
    @Override
    public Plant setName(String name) {
        super.setName(name);
        return this;
    }

    /**
     * Updates the growth rate based on current weather conditions.
     * This is a template method that defines the algorithm structure.
     * 
     * @param currentWeather Current weather condition
     */
    public final void updateGrowthRate(Weather currentWeather) {
        float growthAdjustment = getWeatherGrowthAdjustment(currentWeather);
        this.growthRate += this.growthRate * growthAdjustment;
    }

    /**
     * Gets the growth adjustment factor for a specific weather condition.
     * This is meant to be implemented by subclasses to provide specialized behavior.
     * 
     * @param weather The current weather condition
     * @return A float value representing the growth rate adjustment factor
     */
    protected abstract float getWeatherGrowthAdjustment(Weather weather);

    /**
     * Creates a copy of this plant. Must be implemented by concrete subclasses.
     * 
     * @return A new instance of the same plant type
     */
    @Override
    public abstract Plant clone();

    /**
     * Creates a clone for asexual reproduction.
     * Reproduction is only possible if plant has sufficient health (at least 40%).
     * Parent plant loses health when reproducing.
     * 
     * @return A new plant instance or null if reproduction fails
     */
    public Plant createClone() {
        // Simple health check - must be at least 40% healthy to reproduce
        if (this.health < this.getMaxHealth() * 0.4f) {
            return null; // Too unhealthy to reproduce
        }
        
        Plant clone = clone(); // This calls the concrete subclass implementation
        if (clone != null) {
            // Simple health setting - offspring gets 60% of max health
            clone.health = clone.getMaxHealth() * 0.6f;
            
            clone.growthRate = this.growthRate;
            clone.energyCycleState = this.energyCycleState;
            
            // Simple health cost - reproduction costs 15% of max health
            this.health -= this.getMaxHealth() * 0.15f;
            
            return clone;
        }
        return null;
    }

    /**
     * Performs asexual reproduction to create a new plant.
     * 
     * @return A new plant created through asexual reproduction, or null if reproduction fails
     */
    public Plant performAsexualReproduction() {
        return createClone();
    }

    /**
     * Handles environmental events that the plant is observing.
     * Currently responds to weather changes and time of day changes.
     * 
     * @param observable The observable object that triggered the update
     */
    @Override
    public void update(Observable observable) {
        Event event = observable.getCurrentState();
        switch (event) {
            case Weather newWeather -> handleWeatherUpdate(newWeather);
            case TimeOfDay newTimeOfDay -> handleTimeOfDayUpdate(newTimeOfDay);
            default -> {
            }
        }
    }

    /**
     * Handles weather changes by updating growth rate and performing energy cycle.
     * Also applies health-based adjustments to growth rate.
     * 
     * @param weather The new weather condition
     */
    public void handleWeatherUpdate(Weather weather) {
        // Handle weather changes by updating growth rate
        this.updateGrowthRate(weather);
        this.adjustGrowthRateForHealth(); // Apply health effects to growth rate
        this.performEnergyCycle(weather);
    }
    
    /**
     * Adjusts growth rate based on current health percentage.
     * Plants with lower health have reduced growth rates:
     * - Below 30% health: 50% growth reduction
     * - 30-70% health: 20% growth reduction
     * - Above 70% health: No reduction
     */
    protected void adjustGrowthRateForHealth() {
        // Simple threshold-based growth penalty
        float healthPercentage = this.health / this.getMaxHealth();
        
        // Just two simple thresholds
        if (healthPercentage < 0.3f) {
            // Severe growth penalty for very low health
            this.growthRate *= 0.5f;  // 50% reduction
        } else if (healthPercentage < 0.7f) {
            // Minor growth penalty for moderately low health
            this.growthRate *= 0.8f;  // 20% reduction
        }
        // No penalty for health >= 70%
    }

    /**
     * Handles time of day changes by updating the plant's energy cycle state.
     * Transitions between photosynthesis (day) and respiration (night).
     * 
     * @param timeOfDay The new time of day
     */
    public void handleTimeOfDayUpdate(TimeOfDay timeOfDay) {
        // Handle time of day changes by setting appropriate energy cycle state
        this.energyCycleState = this.energyCycleState.handleTimeOfDayChange(this, timeOfDay);
    }
    
    /**
     * Sets the energy cycle state of the plant.
     * 
     * @param state The new energy cycle state
     */
    public void setEnergyCycleState(EnergyCycleState state) {
        this.energyCycleState = state;
    }

    /**
     * Performs the plant's energy cycle based on current state and weather.
     * This method:
     * 1. Calls the current energy cycle state to calculate health changes and modify growth rate
     * 2. Applies health-based efficiency modifiers to the health change
     * 3. Updates plant health with the final adjusted value
     * 
     * Note: Growth rate is modified directly by the energy cycle state, while
     * health changes are returned and then adjusted based on current health before being applied.
     * 
     * Plants with lower health (below 50%) get less benefit from positive energy cycles
     * and take more damage from negative energy cycles.
     * 
     * @param currentWeather Current weather condition affecting energy cycle
     */
    public void performEnergyCycle(Weather currentWeather) {
        if (this.energyCycleState != null && !isDead()) {
            // Get base health change from energy cycle
            float healthChange = this.energyCycleState.performEnergyCycle(growthRate, currentWeather);
            
            float healthPercentage = this.health / this.getMaxHealth();
            if (healthPercentage < 0.5f) {
                // Low health plants get less benefit/more harm
                if (healthChange > 0) {
                    healthChange *= 0.7f;  // Reduced benefit
                } else {
                    healthChange *= 1.3f;  // Increased harm
                }
            }
            
            // Apply the health change
            adjustHealth(healthChange);
        }
    }

    /**
     * Called when an animal eats this plant. Reduces health based on bite damage.
     * Healthier plants (above 70% health) have 20% damage resistance.
     */
    public void beEaten() {
        this.biteCapacity--;
        
        // Base damage
        float damage = this.getMaxHealth() / BITE_DIVISOR;
        
        // Simple health-based adjustment - just one threshold 
        if (this.health > this.getMaxHealth() * 0.7f) {
            // Healthy plants resist damage better
            damage *= 0.8f; // 20% less damage when healthy
        }
        
        // Apply damage
        this.health -= damage;
        
        // Ensure health doesn't go below zero
        if (this.health < 0) {
            this.health = 0.0f;
        }
    }

    /**
     * Checks if the plant is dead based on its health. Implemented in EcosystemMan?
     * 
     * @return true if the plant is dead (health <= threshold), false otherwise
     */
    public boolean isDead() {
        return this.health <= HEALTH_THRESHOLD;
    }

    /**
     * Adds specified amount to plant's health, capped at max health.
     * Health cannot go below zero.
     * 
     * @param amount Amount to add to health (can be negative for damage)
     */
    public void adjustHealth(float amount) {
        this.health = Math.min(this.health + amount, this.getMaxHealth());
        this.health = Math.max(this.health, 0.0f); // Don't allow negative health
    }
}


</code>

organism\plant\concrete\DesertPlant.java:
<code>
package ecosim.organism.plant.concrete;

import ecosim.enm.Weather;
import ecosim.misc.SpeciesNumbering;
import ecosim.organism.plant.abs.Plant;

/**
 * Abstract class for all desert plants in the ecosystem simulation.
 * 
 * This class provides desert-specific implementation of growth rate adjustments
 * based on weather conditions. Desert plants generally favor sunny weather
 * and are less affected by dry conditions than other plant types.
 * 
 * @author MiaBorkoo
 */
public class DesertPlant extends Plant {

    /**
     * Updates the growth rate of desert plants based on current weather.
     * Desert plants have specialized responses to different weather conditions, e.g Snowy weather is bad for them.
     * 
     * @param currentWeather Current weather condition
     */
    @Override
    protected float getWeatherGrowthAdjustment(Weather weather) {
        return switch (weather) {
            case SUNNY -> 0.1f;
            case RAINY -> 0.05f;
            case DRY -> -0.2f;
            case CLOUDY -> 0.02f;
            case SNOWY -> -0.3f;
        };
    }

    @Override
    public Plant clone() {
        DesertPlant clone = new DesertPlant();
        clone.setName(SpeciesNumbering.generateCloneName(this.getName()));
        return clone;
    }

}

</code>

organism\plant\concrete\GrasslandPlant.java:
<code>
package ecosim.organism.plant.concrete;

import ecosim.enm.Weather;
import ecosim.misc.SpeciesNumbering;
import ecosim.organism.plant.abs.Plant;

/**
 * Abstract class for all grassland plants in the ecosystem simulation.
 * 
 * This class provides grassland-specific implementation of growth rate adjustments
 * based on weather conditions. Grassland plants generally favor a balance of
 * sun and rain, and suffer significantly during dry periods.
 * 
 * @author MiaBorkoo
 */
public class GrasslandPlant extends Plant {

    /**
     * Updates the growth rate of grassland plants based on current weather.
     * 
     * @param currentWeather Current weather condition
     */
    @Override
    protected float getWeatherGrowthAdjustment(Weather weather) {
        return switch (weather) {
            case SUNNY -> 0.08f;
            case RAINY -> 0.12f;
            case DRY -> -0.25f;
            case CLOUDY -> 0.04f;
            case SNOWY -> -0.15f;
        };
    }

    @Override
    public Plant clone() {
        GrasslandPlant clone = new GrasslandPlant();
        clone.setName(SpeciesNumbering.generateCloneName(this.getName()));
        return clone;
    }

}

</code>

organism\plant\energy_cycle_state\EnergyCycleState.java:
<code>
package ecosim.organism.plant.energy_cycle_state;
import ecosim.enm.TimeOfDay;
import ecosim.enm.Weather;
import ecosim.organism.plant.abs.Plant;

/**
 * Interface representing a plant's energy cycle state.
 * 
 * This interface is part of the State pattern implementation for plant energy cycles.
 * Plants alternate between different energy states (photosynthesis/respiration)
 * based on time of day. Each state affects plant health and growth differently.
 * 
 * The energy cycle state:
 * - Determines how the plant generates/consumes energy
 * - Adjusts plant health based on current conditions
 * - Modifies growth rate based on environmental factors
 * - Handles transitions between different energy states
 * 
 * @author MiaBorkoo
 */
public interface EnergyCycleState {
    /**
     * Performs the energy cycle calculation with dual effects on health and growth.
     * This method:
     * 1. Calculates health adjustment based on weather and plant state
     * 2. Modifies the plant's growth rate (applied to the passed parameter)

     * @param growthRate Current growth rate of the plant (modified by this method)
     * @param currentWeather Current weather affecting the energy cycle
     * @return The amount to adjust the plant's health by (positive or negative)
     */
    float performEnergyCycle(float growthRate, Weather currentWeather);
    
    /**
     * Handles time of day changes and determines if a state transition is needed.
     * For example, transitions from photosynthesis to respiration at nightfall.
     * 
     * @param plant The plant affected by the time change
     * @param timeOfDay The new time of day
     * @return The appropriate state after handling time change (this or new state)
     */
    EnergyCycleState handleTimeOfDayChange(Plant plant, TimeOfDay timeOfDay);
}


</code>

organism\plant\energy_cycle_state\PhotosynthesisState.java:
<code>
package ecosim.organism.plant.energy_cycle_state;

import ecosim.enm.TimeOfDay;
import ecosim.enm.Weather;
import ecosim.organism.plant.abs.Plant;

/**
 * Implementation of the plant energy cycle state during daytime (photosynthesis).
 * 
 * This class represents the active energy production state of plants, where they:
 * - Convert sunlight, water and CO2 into energy
 * - Generally increase in health during favorable conditions
 * - Adjust growth rates based on weather conditions
 * 
 * Photosynthesis is most effective in sunny conditions, but still functions
 * in other weather types with varying degrees of efficiency. This state
 * transitions to the respiration state when night falls.
 * 
 * @author MiaBorkoo
 */
public class PhotosynthesisState implements EnergyCycleState {
    /**
     * Performs the photosynthesis energy cycle, calculating health adjustments
     * and growth rate changes based on current weather conditions.
     * 
     * This method has two effects:
     * 1. It calculates and returns a health adjustment value (usually positive during day)
     * 2. It directly modifies the provided growthRate parameter based on weather
     * 
     * @param growthRate Current growth rate of the plant (modified by this method)
     * @param currentWeather Current weather affecting photosynthesis
     * @return Amount to adjust plant health (usually positive during day)
     */
    @Override
    public float performEnergyCycle(float growthRate, Weather currentWeather) {
        float adjustedGrowthRate;
        float healthAdjustment;

        // Both growth rate and health adjustments
        switch (currentWeather) {
            case SUNNY -> {
                adjustedGrowthRate = growthRate * 1.15f;
                healthAdjustment = 2.0f; // Good health increase during sunny conditions
            }
            case DRY -> {
                adjustedGrowthRate = growthRate * 1.07f;
                healthAdjustment = 0.5f; // Smaller health increase during dry conditions
            }
            case RAINY -> {
                adjustedGrowthRate = growthRate * 1.1f;
                healthAdjustment = 1.5f; // Good health increase during rain
            }
            case SNOWY -> {
                adjustedGrowthRate = growthRate * 0.8f;
                healthAdjustment = -0.5f; // Small health decrease during snow
            }
            default -> {
                adjustedGrowthRate = growthRate * 1.02f;
                healthAdjustment = 0.2f; // Small health increase for other conditions
            }
        }

        growthRate += adjustedGrowthRate; // Update the growth rate
        
        return healthAdjustment;
    }

    /**
     * Handles time of day transitions, switching to respiration state at night.
     * 
     * @param plant The plant experiencing the time change
     * @param timeOfDay The new time of day
     * @return This state if still day, or a new RespirationState if night
     */
    @Override
    public EnergyCycleState handleTimeOfDayChange(Plant plant, TimeOfDay timeOfDay) {
        if (timeOfDay == TimeOfDay.NIGHT) {
            return new RespirationState();
        }
        return this; // Stay in photosynthesis state during day
    }
}
</code>

organism\plant\energy_cycle_state\RespirationState.java:
<code>
package ecosim.organism.plant.energy_cycle_state;

import ecosim.enm.TimeOfDay;
import ecosim.enm.Weather;
import ecosim.organism.plant.abs.Plant;

/**
 * Implementation of the plant energy cycle state during nighttime (respiration).
 * 
 * This class represents the energy consumption state of plants, where they:
 * - Consume stored energy for cellular maintenance
 * - Generally decrease in health as they use resources
 * - Experience reduced growth rates during all weather conditions
 * 
 * Respiration is a necessary process for plants, but results in net energy consumption
 * rather than production. The severity of health decrease varies by weather condition,
 * with harsh weather causing more significant health decreases. This state
 * transitions back to the photosynthesis state when day returns.
 * 
 * @author MiaBorkoo
 */
public class RespirationState implements EnergyCycleState {
    /**
     * Performs the respiration energy cycle, calculating health adjustments
     * and growth rate changes based on current weather conditions.
     * 
     * This method has two effects:
     * 1. It calculates and returns a health adjustment value (usually negative during night)
     * 2. It directly modifies the provided growthRate parameter based on weather
     * 
     * @param growthRate Current growth rate of the plant (modified by this method)
     * @param currentWeather Current weather affecting respiration
     * @return Amount to adjust plant health (usually negative during night)
     */
    @Override
    public float performEnergyCycle(float growthRate, Weather currentWeather) {
        float adjustedGrowthRate;
        float healthAdjustment;
        
        // Handle both growth and health adjustments
        switch (currentWeather) {
            case SUNNY -> {
                adjustedGrowthRate = growthRate * -0.05f; // Minor growth decrease even in good conditions
                healthAdjustment = -0.2f; // Minimal health decrease in good conditions
            }
            case DRY -> {
                adjustedGrowthRate = growthRate * -0.15f; // More significant growth decrease
                healthAdjustment = -1.0f; // More health decrease in dry conditions at night
            }
            case RAINY -> {
                adjustedGrowthRate = growthRate * -0.08f; // Moderate growth decrease
                healthAdjustment = -0.4f; // Moderate health decrease during rain at night
            }
            case SNOWY -> {
                adjustedGrowthRate = growthRate * -0.25f; // Significant growth decrease
                healthAdjustment = -1.5f; // Significant health decrease in snow at night
            }
            default -> {
                adjustedGrowthRate = growthRate * -0.1f; // Default growth decrease
                healthAdjustment = -0.5f; // Default health decrease during night
            }
        }
        
        growthRate += adjustedGrowthRate; // Update the growth rate

        return healthAdjustment;
    }

    /**
     * Handles time of day transitions, switching to photosynthesis state at day.
     * 
     * @param plant The plant experiencing the time change
     * @param timeOfDay The new time of day
     * @return This state if still night, or a new PhotosynthesisState if day
     */
    @Override
    public EnergyCycleState handleTimeOfDayChange(Plant plant, TimeOfDay timeOfDay) {
        if (timeOfDay == TimeOfDay.DAY) {
            return new PhotosynthesisState();
        }
        return this; // Stay in respiration state during night
    }
}
</code>

view\ActionResultListener.java:
<code>
package ecosim.view;

import ecosim.map.ActionResult;

public interface ActionResultListener {
    void onActionPerformed(ActionResult result);
}


</code>

view\ActionsView.java:
<code>
package ecosim.view;

import static ecosim.common.io.ConsoleIO.add;
import ecosim.map.ActionResult;
import ecosim.map.ActionResult.ActionType;
import ecosim.organism.Organism;
import ecosim.organism.animal.abs.Animal;

public class ActionsView {

    public void displayAnimalActionsHeader() {
        StringBuilder str = new StringBuilder();
        add.accept(str, "** [fly:Today's Animal Highlights] **");
        System.out.println(str.toString());
    }

    public void displayAnimalActions(ActionResult result) {
        // Skip displaying movement or idle actions
        if (result.getActionType() == ActionType.BASIC_ACTION) {
            return;
        }

        StringBuilder str = new StringBuilder();


        if (result.getActor() == null) {
            add.accept(str, "  Mystery action occurred!");
            System.out.println(str.toString());
            return;
        }

        Animal actor = result.getActor();
        Organism target = result.getTarget();

        // Format and add the action message
        String message = formatActionMessage(
            actor,
            target,
            result.getActionType(),
            result.getNewX(),
            result.getNewY());

        add.accept(str, "  " + message);
        System.out.println(str.toString());
    }

    private String formatActionMessage(Animal actor, Organism target, ActionType actionType, int newX, int newY) {
        String actorName = actor.getName();
        String actorSymbol = actor.getSymbol();
        String sound = actor.getSound();

        return switch (actionType) {
            case DIED -> formatAttemptedDeathMessage(actorName, actorSymbol, sound);
            case ATTEMPTED_BREEDING -> formatAttemptedBreedingMessage(actorName, actorSymbol, target, sound);
            case SUCCESSFUL_BREEDING -> formatSuccessfulBreedingMessage(actorName, actorSymbol, target, sound);
            case ATTEMPTED_EATING -> formatAttemptedEatingMessage(actorName, actorSymbol, target, sound);
            case SUCCESSFUL_EATING -> formatSuccessfulEatingMessage(actorName, actorSymbol, target, sound);
            default -> null; 
        };
    }

    private String formatAttemptedDeathMessage(String actorName, String actorSymbol, String sound) {
        return String.format("(üíÄ) %s %s has died from starvation. %s", actorSymbol, actorName, sound);
    }

    private String formatAttemptedBreedingMessage(String actorName, String actorSymbol, Organism target, String sound) {
        if (target != null) {
            String targetName = target.getName();
            String targetSymbol = target.getSymbol(); // Assuming getSymbol() exists
            return String.format("(üíî) %s %s got rejected by %s %s. %s", actorSymbol, actorName, targetSymbol,
                targetName, sound);
        }
        return String.format("(üíî) %s %s tries dating app. No matches. %s", actorSymbol, actorName, sound);
    }

    private String formatSuccessfulBreedingMessage(String actorName, String actorSymbol, Organism target,
        String sound) {
        if (target != null) {
            String targetName = target.getName();
            String targetSymbol = target.getSymbol();
            return String.format("(‚ù§Ô∏è) %s %s breeds with %s %s! Baby time! %s",
                actorSymbol, actorName, targetSymbol, targetName, sound);
        }
        return String.format("(‚ù§Ô∏è) %s %s somehow has a baby! %s", actorSymbol, actorName, sound);
    }

    private String formatAttemptedEatingMessage(String actorName, String actorSymbol, Organism target, String sound) {
        if (target != null) {
            String targetName = target.getName();
            String targetSymbol = target.getSymbol();
            return String.format("(ü•∫üçΩÔ∏è) %s %s tried eating %s %s but failed. %s",
                actorSymbol, actorName, targetSymbol, targetName, sound);
        }
        return String.format("(ü•∫üçΩÔ∏è)%s %s missed lunch. %s", actorSymbol, actorName, sound);
    }

    private String formatSuccessfulEatingMessage(String actorName, String actorSymbol, Organism target, String sound) {
        if (target != null) {
            String targetName = target.getName();
            String targetSymbol = target.getSymbol();
            return String.format("(üòåüçΩÔ∏è) %s %s devoured %s %s! %s",
                actorSymbol, actorName, targetSymbol, targetName, sound);
        }
        return String.format("(üòåüçΩÔ∏è) %s %s had a tasty meal! %s", actorName, actorSymbol, sound);
    }
}
</code>

view\EnvironmentView.java:
<code>
package ecosim.view;

import static ecosim.common.io.ConsoleIO.add;
import ecosim.enm.ActivityState;
import ecosim.man.EcosystemMan;

public class EnvironmentView {


    public void displayTimeStatus(EcosystemMan ecosystem) {
        StringBuilder str = new StringBuilder();
    
        add.accept(str, "**‚è±Ô∏è [fly:Simulation Time] ‚è±Ô∏è**\n");
        add.accept(str, "  **Day:** [flc:%d]".formatted(ecosystem.getDayCount()));
        add.accept(str, "  **Time of Day:** [flc:%s] %s".formatted(
            ecosystem.getCurrentTimeOfDay().name(),
            ecosystem.getCurrentTimeOfDay().getIcon()));
        System.out.println(str.toString());
        this.displaySleepingAnimals(ecosystem);
    }
    
    public void displayEnvironmentConditions(EcosystemMan ecosystem) {  
        // Display environment conditions
        StringBuilder envStr = new StringBuilder();
        add.accept(envStr, "**üåç [fly:Environment Status] üåç**\n");
    
        add.accept(envStr, "  **Weather:** [flc:%s] %s".formatted(
            ecosystem.getCurrentWeather().name(),
            ecosystem.getCurrentWeather().getIcon()));
    
        add.accept(envStr, "  **Season:** [flc:%s] %s".formatted(
            ecosystem.getCurrentSeason().name(),
            ecosystem.getCurrentSeason().getIcon()));
    
        System.out.println(envStr.toString());
    }

    public void displaySleepingAnimals(EcosystemMan ecosystem) {
        var sleepingAnimals = ecosystem.getAnimals().stream()
            .filter(animal -> animal.getActivityState() == ActivityState.SLEEPING)
            .toList();
        
        if (!sleepingAnimals.isEmpty()) {
            StringBuilder str = new StringBuilder();
            
            add.accept(str, "**üò¥ [flm:Sleeping Animals] üò¥**\n");
            
            sleepingAnimals.forEach(animal -> {
                add.accept(str, "  > %s".formatted(
                    animal.getName()));
            });
            
            System.out.println(str.toString());
        }
    }
    
    
    public void displayHibernatingAnimals(EcosystemMan ecosystem) {
        var hibernatingAnimals = ecosystem.getAnimals().stream()
            .filter(animal -> animal.getActivityState() == ActivityState.HIBERNATING)
            .toList();
        
        if (!hibernatingAnimals.isEmpty()) {
            StringBuilder str = new StringBuilder();
            
            add.accept(str, "**‚ùÑÔ∏è [flm:Hibernating Animals] ‚ùÑÔ∏è**\n");
            
            hibernatingAnimals.forEach(animal -> {
                add.accept(str, "  > %s".formatted(
                    animal.getName()));
            });
            
            System.out.println(str.toString());
        }
    }
}
</code>

view\InputPromptView.java:
<code>
package ecosim.view;


import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import ecosim.enm.Biome;
import ecosim.menu.AnimalMenu;
import ecosim.menu.BiomeMenu;
import ecosim.menu.PlantMenu;
import ecosim.misc.AnimalDescriptor;
import ecosim.misc.PlantDescriptor;


public class InputPromptView {
    /**
     * Prompts the user to select a biome from the available options.
     * 
     * @return The selected biome
     */
    public Biome promptBiomeSelection() {
        final BiomeMenu menu = new BiomeMenu(Biome.values());
        menu.print();

        final Biome choice = menu.getUserChoice();
        System.out.println();

        return choice;
    }

    /**
     * Prompts the user to select a specified number of animal species from the available options.
     * 
     * @param animals The list of available animal descriptors
     * @param num The number of animals to select
     * @return List of selected animal descriptors
     */
    public List<AnimalDescriptor> promptAnimalSelection(List<AnimalDescriptor> animals, int num) {
        // Extract just the names for the menu
        final List<String> animalNames = animals.stream()
            .map(AnimalDescriptor::name)
            .collect(Collectors.toList());

        // Create a menu with animal names
        final AnimalMenu menu = new AnimalMenu(animalNames);
        menu.print();

        final List<AnimalDescriptor> selectedDescriptors = new ArrayList<>();

        // Get user selections
        for (int i = 0; i < num; i++) {
            String chosenName = menu.getUserChoice("Enter your choice (%d) >> ".formatted(i + 1));

            // Find the descriptor with the matching name
            AnimalDescriptor descriptor = animals.stream()
                .filter(a -> a.name().equals(chosenName))
                .findFirst()
                .orElse(null);

            if (descriptor != null) {
                selectedDescriptors.add(descriptor);
            }
        }
        System.out.println();

        return selectedDescriptors;
    }

    /**
     * Prompts the user to select a specified number of plant species from the available options.
     * 
     * @param plants The list of available plant descriptors
     * @param num The number of plants to select
     * @return List of selected plant descriptors
     */
    public List<PlantDescriptor> promptPlantSelection(List<PlantDescriptor> plants, int num) {
        // Extract just the names for the menu
        final List<String> plantNames = plants.stream()
            .map(PlantDescriptor::name)
            .collect(Collectors.toList());

        // Create a menu with plant names
        final PlantMenu menu = new PlantMenu(plantNames);
        menu.print();

        final List<PlantDescriptor> selectedDescriptors = new ArrayList<>();

        // Get user selections
        for (int i = 0; i < num; i++) {
            String chosenName = menu.getUserChoice("Enter your choice (%d) >> ".formatted(i + 1));

            // Find the descriptor with the matching name
            PlantDescriptor descriptor = plants.stream()
                .filter(p -> p.name().equals(chosenName))
                .findFirst()
                .orElse(null);

            if (descriptor != null) {
                selectedDescriptors.add(descriptor);
            }
        }
        System.out.println();

        return selectedDescriptors;
    }

}

</code>

view\MapView.java:
<code>
package ecosim.view;

import static ecosim.common.io.ConsoleIO.add;
import static ecosim.common.io.ConsoleIO.pprintln;
import ecosim.common.io.enm.BoxDrawingChar;
import ecosim.man.EcosystemMan;
import ecosim.map.Grid;
import ecosim.organism.Organism;

public class MapView {
     public void displayEcosytemMap(EcosystemMan ecosystem) {
        final String EMPTY_CELL = ".";
        final int height = ecosystem.getMapSize().height();
        final int width = ecosystem.getMapSize().width();
        Grid grid = ecosystem.getMapGrid();
        final StringBuilder sb = new StringBuilder();
        final String border = BoxDrawingChar.HORIZONTAL.repeat(width * 4); // Adjust border width for consistent cells

        add.accept(sb, "**üó∫Ô∏è [fly:Where is Everyone?] üó∫Ô∏è**\n");

        sb.append("**")
            .append(BoxDrawingChar.TOP_LEFT.getValue())
            .append(border)
            .append(BoxDrawingChar.TOP_RIGHT.getValue())
            .append("**\n");

        for (int y = height - 1; y >= 0; y--) {
            sb.append("**")
                .append(BoxDrawingChar.VERTICAL.getValue())
                .append("**");

            for (int x = 0; x < width; x++) {
                final String ch = grid.get(x, y)
                    .map(Organism::getSymbol)
                    .orElse(EMPTY_CELL);

                // Adjust spacing based on character type
                if (isWideCharacter(ch)) {
                    sb.append(" ").append(ch).append(" ");
                } else {
                    sb.append(" ").append(ch).append("  ");
                }
            }

            sb.append("**")
                .append(BoxDrawingChar.VERTICAL.getValue())
                .append("**\n");
        }

        sb.append("**")
            .append(BoxDrawingChar.BOTTOM_LEFT.getValue())
            .append(border)
            .append(BoxDrawingChar.BOTTOM_RIGHT.getValue())
            .append("**\n");

        pprintln(sb.toString());
    }

    private boolean isWideCharacter(String ch) {
        if (ch == null || ch.isEmpty())
            return false;

        // Simple heuristic: if it's not ASCII and not a common symbol, assume it's wide
        char c = ch.charAt(0);
        return c > 127 || ch.codePointAt(0) > 127;
    }

}

</code>

view\ReportView.java:
<code>
package ecosim.view;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static ecosim.common.io.ConsoleIO.add;
import ecosim.man.EcosystemMan;
import ecosim.organism.Organism;
import ecosim.organism.plant.abs.Plant;

public class ReportView {
public void displayDailyReport(EcosystemMan ecosystem) {
        StringBuilder str = new StringBuilder();
        add.accept(str, "**‚ú® [fly:Day %d Report] ‚ú®**\n".formatted(ecosystem.getDayCount()));
        add.accept(str, "  **[flc:Headcount:]**");
        add.accept(str, "    Animals: **[flc:%d]**".formatted(ecosystem.getAnimalCount()));
        add.accept(str, "    Plants:  **[flc:%d]**\n".formatted(ecosystem.getPlantCount()));
        add.accept(str, "  **[flc:Statistics:]**");

        int maxWidth = calculateMaxWidth(ecosystem);
        addOrganismReport("Animals", ecosystem.getAnimals(), str, maxWidth);
        addOrganismReport("Plants", ecosystem.getPlants(), str, maxWidth);

        addLifeCycleReport("Animals", ecosystem.getNewbornAnimals(), ecosystem.getDeadAnimals(), str, maxWidth);

        List<Plant> emptyPlantsList = new ArrayList<>(); // placeholder
        addLifeCycleReport("Plants", emptyPlantsList, ecosystem.getDeadPlants(), str, maxWidth);

        System.out.println(str.toString());
    }

    private int calculateMaxWidth(EcosystemMan ecosystem) {
        int animalMaxLength = ecosystem.getAnimals().stream()
            .mapToInt(o -> o.getName().length())
            .max()
            .orElse(0);

        int plantMaxLength = ecosystem.getPlants().stream()
            .mapToInt(o -> o.getName().length())
            .max()
            .orElse(0);

        return Math.max(Math.max(animalMaxLength, plantMaxLength), "Thriving Animals:".length());
    }

    private <T extends Organism> void addOrganismReport(final String type, List<T> organisms, StringBuilder str,
        int maxWidth) {
        final int gap = 10;
        final double goodHealthPercentage = 0.6; // 70% of maximum health
        final double poorHealthPercentage = 0.4; // 30% of maximum health

        final List<T> thriving = organisms.stream()
            .filter(o -> {
                double healthPercentage = (double) o.getHealth() / o.getMaxHealth();
                return healthPercentage >= goodHealthPercentage;
            })
            .collect(Collectors.toList());

        final List<T> declining = organisms.stream()
            .filter(o -> {
                double healthPercentage = (double) o.getHealth() / o.getMaxHealth();
                return healthPercentage < poorHealthPercentage;
            })
            .collect(Collectors.toList());

        final String thrivingHeader = "Thriving %s:".formatted(type);
        final String decliningHeader = "Declining %s:".formatted(type);

        int headerPadding = maxWidth - thrivingHeader.length() + gap;
        final String fStr =
            "    [flg:%s]%s[flr:%s]".formatted(thrivingHeader, " ".repeat(headerPadding), decliningHeader);
        add.accept(str, fStr);

        final int maxRows = Math.max(thriving.size(), declining.size());

        for (int i = 0; i < maxRows; i++) {
            StringBuilder row = new StringBuilder();

            if (i < thriving.size()) {
                final String name = thriving.get(i).getName();
                final String rowStr = String.format("      > %s", name);
                row.append(rowStr);

                int padding = maxWidth - rowStr.length() + gap;
                if (padding > 0)
                    row.append(" ".repeat(padding));
            } else {
                row.append(" ".repeat(maxWidth + gap));
            }

            if (i < declining.size())
                row.append("      > %s".formatted(declining.get(i).getName()));

            add.accept(str, row.toString());
        }
        add.accept(str, "");
    }

    private <T extends Organism> void addLifeCycleReport(String type, List<T> newborns, List<T> deceased,
        StringBuilder str, int maxWidth) {
        final int gap = 10;

        // Column headers
        final String newbornHeader = "New %s:".formatted(type);
        final String deceasedHeader = "Deceased %s:".formatted(type);

        int headerPadding = maxWidth - newbornHeader.length() + gap;
        final String headerStr =
            "    [flg:%s]%s[flr:%s]".formatted(newbornHeader, " ".repeat(headerPadding), deceasedHeader);
        add.accept(str, headerStr);

        final int maxRows = Math.max(newborns.size(), deceased.size());
        if (maxRows == 0) {
            add.accept(str, " ".repeat(maxWidth - 1));
        } else {

            for (int i = 0; i < maxRows; i++) {
                StringBuilder row = new StringBuilder();

                // Left column (newborns)
                if (i < newborns.size()) {
                    T organism = newborns.get(i);
                    String rowStr = String.format("      > %s ", organism.getName());
                    row.append(rowStr);

                    int padding = maxWidth - rowStr.length() + gap;
                    if (padding > 0)
                        row.append(" ".repeat(padding));
                } else {
                    row.append(" ".repeat(maxWidth + gap));
                }

                // Right column (deceased)
                if (i < deceased.size()) {
                    T organism = deceased.get(i);
                    row.append(String.format("      > %s", organism.getName()));
                }

                add.accept(str, row.toString());
            }
        }

        add.accept(str, "");
    }

    
}

</code>

view\SplashScreenView.java:
<code>
package ecosim.view;


import static ecosim.common.io.ConsoleIO.clearTerminal;
import static ecosim.common.io.ConsoleIO.cursorUp;
import static ecosim.common.io.ConsoleIO.getTermLines;
import static ecosim.common.io.ConsoleIO.pprintCenter;
import static ecosim.common.io.ConsoleIO.pprintln;
import static ecosim.common.io.ConsoleIO.strInput;
import static ecosim.common.io.ConsoleIO.toggleCursor;


public final class SplashScreenView {

    private static final short TITLE_HEIGHT = 7;
    private static final String TITLE = """
                                [flc:_        \s
          ___  _________  _____(_)___ ___\s
         / _ \\/ ___/ __ \\/ ___/ / __ `__ \\
        /  __/ /__/ /_/ (__  ) / / / / / /
        \\___/\\___/\\____/____/_/_/ /_/ /_/\s

        ][fly:An Ecosystem Simulator]""";

    private static final short GRAPHIC_HEIGHT = 9;
    private static final String GRAPHIC = """
        **          [flg:_-_]                         [flm:/^-^\\]      \s
               [flg:/~~   ~~\\]            [fly:.-",]                 \s
            [flg:/~~         ~~\\]           [fly:||]             [flr:/^-^\\]
           [flg:{               }]          [fly:||]                \s
            [flg:\\  _-     -_  /]          [fly:(':.)`]             \s
              [flg:~  \\   /  ~]            [fly:|| ||]              \s
                  [fdy:| |]                [fly:|| ||]              \s
                  [fdy:| |]                [fly:|| ||]              \s
        [flg:‚£†‚£§‚£§‚£§‚£Ä‚£†‚£§‚£§‚£§‚£§‚£§‚£§‚£Ä‚£§‚£§‚£§‚£Ñ‚£Ä‚£§‚£§‚£§‚£§‚£Ñ‚£Ä‚£§‚£§‚£§‚£Ñ‚£Ä‚£Ñ‚£Ä‚£§‚£§‚£§‚£§‚£§‚£§‚£Ä‚£§‚£§‚£§‚£Ñ‚£Ä‚£§‚£§‚£§‚£§‚£Ñ‚£Ä‚£§‚£§‚£§‚£Ñ‚£Ä‚£Ñ‚£Ä‚£§‚£§‚£§‚£§‚£Ñ‚£Ä‚£§‚£§‚£§‚£Ñ‚£Ä‚£§‚£§‚£§‚£§‚£Ñ‚£Ä‚£†‚£Ñ]**""";

    private SplashScreenView() {
        throw new UnsupportedOperationException("This class cannot be instantiated.");
    }

    public static void show() {
        final int gap = Math.max(getTermLines() - TITLE_HEIGHT - GRAPHIC_HEIGHT - 1, 10);

        clearTerminal();
        pprintCenter(TITLE);
        System.out.print("\n".repeat(gap));
        pprintCenter(GRAPHIC);
        cursorUp((gap / 2) + GRAPHIC_HEIGHT);
        toggleCursor(false);
        pprintCenter("Press **[flr:Enter]** to start");
        strInput(true);
        toggleCursor(true);
        clearTerminal();
    }

    public void welcome() {
        SplashScreenView.show();
        pprintln("Welcome to the *Ecosystem Simulator* üå≥");
        pprintln("To setup the ecosystem, please follow the prompts below.\n");
    }

    public void end(int exitCode) {
        toggleCursor(true);
        pprintln("\n[flr:(Simulator finished w/ exit code %d)]", exitCode);
    }


}

</code>

